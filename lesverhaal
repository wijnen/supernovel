#!/usr/bin/python3
# vim: set fileencoding=utf-8 :

# Imports and config. {{{
import sys
import os
import base64
import io
import math
import re
import traceback
import time
import random
import fhs
import websocketd
import json
import userdata
import content
from markdown import markdown
from websocketd import log

fhs.option('port', 'network port to listen for players', default = '7000')
fhs.option('proxy', 'virtual proxy directory', default = 'lesverhaal')
fhs.option('logfile', 'file for logging events', default = '')
fhs.option('loglimit', 'maximum loglevel that is written to screen', default = 1)
config = userdata.fhs_init('http://localhost:8879', 'lesverhaal', help = 'Visual novel style tool for students to learn with teacher monitoring options', contact = 'Bas Wijnen <wijnen@debian.org>', version = '0.2')
from debug import debug
# }}}

''' Log priorities: {{{
		0: Critical (system code errors)
		1: Important (user code errors)
		2: Normal (communication notifications)
		3: Debug
}}} '''

# Sub-/superscript helpers. {{{
tosuper_dict = {'0': '⁰', '1': '¹', '2': '²', '3': '³', '4': '⁴', '5': '⁵', '6': '⁶', '7': '⁷', '8': '⁸', '9': '⁹', '-': '⁻', '+': '⁺', '=': '⁼', '(': '⁽', ')': '⁾', 'n': 'ⁿ'}
def tosuper(src):
	return ''.join(tosuper_dict.get(c, c) for c in src)

fromsuper_dict = {v: k for k, v in tosuper_dict.items()}
def fromsuper(src):
	return ''.join(fromsuper_dict.get(c, c) for c in src)
# }}}

# List of all currently logged in users.
users = {}
admins = {}

def refresh_admins(wake): # {{{
	for a in admins:
		yield from admins[a].refresh(wake)
# }}}

# Class for handling user script commands. {{{
# There can be multiple implementations of te Environment class.
# Only Lua is defined. This is not expected to change.
# It needs to define:
# - constructor with no arguments (or no constructor).
# - set(self, key, value):
#	Set a value in the game's namespace.
# - run(self, wake, script, allow_ui = True):
#	Run code in the game's namespace.
#	If allow_ui is True, animation commands are allowed from the script.
#	This function must be a generator.
# - compute(self, wake, expr, as_str):
#	Run code in the game's namespace and return a value.
#	The value is a str if as_str is True, a bool otherwise.
#	This function must be a generator.

class Lua: # Run Lua code. {{{
	'''This class handles the userspace lua environment.
	It uses the lua library, which is safe for running untrusted code.
	'''
	def __init__(self):
		self.lua = lua.Lua()
	def set(self, key, value):
		self.lua.run(var = key, value = value)
	def run(self, script, allow_ui = True):
		self.lua.run(script)
	def compute(self, expr, as_str):
		#print('computing: ', expr)
		ret = self.lua.run('return ' + expr)
		if as_str:
			return str(ret)
		else:
			return bool(ret)
# }}}

import lua

def Environment():
	return Lua()
# }}}

class Admin_Connection: # {{{ Class for handling admin connections.
	def __init__(self, my_id, my_name, my_userdata, my_remote, managed_name): # {{{
		self.id = my_id
		self.name = my_name
		self.userdata = my_userdata
		self.remote = my_remote
		self.remote._websocket_closed = self._closed
		admins[my_id] = self
		debug(1, 'admin {} connected'.format(self.name))
	# }}}
	def _init(self, wake): # {{{
		self.script = None
		self.refresh = lambda wake: self.remote.scripts.event((yield from content.list(wake, None)))
		yield from self.refresh(wake)
	# }}}
	def _closed(self): # {{{
		del admins[self.id]
		self.remote._websocket_close()
		debug(1, 'disconnecting admin {}'.format(self.name))
	# }}}
	def _send_script(self, wake): # {{{
		log('sending script')
		questions = (yield from content.list_questions(wake, self.script))
		players = (yield from content.list_players(wake, self.script))
		log('sending qp', questions, players)
		self.remote.script.event(questions, players)
	# }}}
	def select_script(self, script): # {{{
		wake = (yield)
		if script is None:
			yield from self._init(wake)
		else:
			self.script = (yield from content.get_scriptid(wake, script))
			self.refresh = self._send_script
			yield from self.refresh(wake)
	# }}}
# }}}

class Content_Connection: # {{{ Class for handling content management.
	def __init__(self, my_id, my_name, my_userdata, my_remote, managed_name): # {{{
		self.id = my_id
		self.name = my_name
		self.userdata = my_userdata
		self.remote = my_remote
		self.managed_name = managed_name
	def _init(self, wake):
		# TODO: Check that this user is allowed to edit content.
		# Other than that, nothing to do here.
		pass
	# }}}
	# Groups {{{
	def list_groups(self):
		wake = (yield)
		data = (yield from serverdata.select('group', ('id', 'name'), wake = wake))
		return {d[0]: {'name': d[1]} for d in data}
	def add_group(self, name):
		wake = (yield)
		yield from serverdata.insert('group', {'name': name}, wake = wake)
		me = (yield from serverdata.select('group', ('id',), ('=', 'name', name), wake = wake))
		return me[0][0]
	def update_group(self, groupid, name):
		wake = (yield)
		yield from serverdata.update('group', {'name': name}, ('=', 'id', groupid), wake = wake)
	def remove_group(self, groupid):
		wake = (yield)
		yield from serverdata.delete('group', ('=', 'id', groupid), wake = wake)
	# }}}
	# Chapters {{{
	def _list_chapters(self, wake):
		data = (yield from serverdata.select('chapter', ('id', 'name'), wake = wake))
		return {d[0]: {'name': d[1]} for d in data}
	def list_chapters(self):
		wake = (yield)
		return (yield from self._list_chapters(wake))
	def add_chapter(self, name, parent):
		wake = (yield)
		yield from serverdata.insert('chapter', {'name': name, 'parent': parent if parent else None}, wake = wake)
		me = (yield from serverdata.select('chapter', ('id',), ('=', 'name', name), wake = wake))
		return me[0][0]
	def update_chapter(self, chapterid, name, parent):
		wake = (yield)
		yield from serverdata.update('chapter', {'name': name, 'parent': parent if parent else None}, ('=', 'id', chapterid), wake = wake)
	def remove_chapter(self, chapterid):
		wake = (yield)
		yield from serverdata.delete('chapter', ('=', 'id', chapterid), wake = wake)
	# }}}
	# Access {{{
	def list_access(self):
		wake = (yield)
		return (yield from serverdata.select('access', ('groupid', 'chapter'), wake = wake))
	def add_access(self, groupid, chapterid):
		wake = (yield)
		present = (yield from serverdata.select('access', ('groupid',), ('and', ('=', 'groupid', groupid), ('=', 'chapter', chapterid)), wake = wake))
		assert len(present) == 0
		yield from serverdata.insert('access', {'groupid': groupid, 'chapter': chapterid}, wake = wake)
	def remove_access(self, groupid, chapterid):
		wake = (yield)
		yield from serverdata.delete('access', ('and', ('=', 'groupid', groupid), ('=', 'chapter', chapterid)), wake = wake)
	# }}}
	# Scripts {{{
	def list_scripts(self):
		wake = (yield)
		data = (yield from serverdata.select('script', ('id', 'name', 'chapter'), wake = wake))
		return {d[0]: {'name': d[1], 'chapter': d[2]} for d in data}
	def get_script(self, scriptid):
		wake = (yield)
		data = (yield from serverdata.select('script', ('script',), ('=', 'id', scriptid), wake = wake))
		return None if len(data) == 0 else data[0][0]
	def _add_script(self, wake, name, chapter, script):
		yield from serverdata.insert('script', {'name': name, 'chapter': chapter, 'script': script}, wake = wake)
	def add_script(self, name, chapter, script):
		wake = (yield)
		yield from self._add_script(wake, name, chapter, script)
		new_scriptid = (yield from serverdata.select('script', ('id',), ('and', ('=', 'name', name), ('=', 'chapter', chapter)), wake = wake))[0]
		return (yield from self._update_questions(wake, new_scriptid, script))
	def update_script(self, scriptid, name, chapter, script):
		wake = (yield)
		if script is None:
			yield from serverdata.update('script', {'name': name, 'chapter': chapter}, ('=', 'id', scriptid), wake = wake)
			return []
		else:
			yield from serverdata.update('script', {'name': name, 'chapter': chapter, 'script': script}, ('=', 'id', scriptid), wake = wake)
			return (yield from self._update_questions(wake, scriptid, script))
	def remove_script(self, scriptid):
		wake = (yield)
		yield from serverdata.delete('script', ('=', 'id', scriptid), wake = wake)
		yield from serverdata.delete('question', ('=', 'script', scriptid), wake = wake)
	# }}}
	# Questions {{{
	def _update_questions(self, wake, scriptid, script):
		parsed, errors, questions = content.parse_script(script)
		#print('questions', questions)
		yield from serverdata.delete('question', ('=', 'script', scriptid), wake = wake)
		for q in questions:
			yield from serverdata.insert('question', {'id': q['id'], 'script': scriptid, 'type': q['type'], 'description': q['description']}, wake = wake)
		return errors
	def list_questions(self):
		wake = (yield)
		data = (yield from serverdata.select('question', ('id', 'script', 'type', 'description'), wake = wake))
		return {('%d:%s' % (d[1], d[0])): {'type': d[2], 'description': d[3]} for d in data}
	# }}}
	# Sprites {{{
	def _list_sprites(self, wake):
		data = (yield from serverdata.select('sprite', ('name', 'chapter', 'id'), wake = wake))
		return {d[2]: {'name': d[0], 'chapter': d[1]} for d in data}
	def list_sprites(self):
		wake = (yield)
		return (yield from self._list_sprites(wake))
	def _add_sprite(self, wake, spriteid, name, chapter):
		yield from serverdata.insert('sprite', {'name': name, 'chapter': chapter, 'id': spriteid}, wake = wake)
	def add_sprite(self, spriteid, name, chapter):
		wake = (yield)
		yield from self._add_sprite(wake, spriteid, name, chapter)
	def update_sprite(self, spriteid, name, chapter):
		wake = (yield)
		yield from serverdata.update('sprite', {'name': name, 'chapter': chapter}, ('=', 'id', spriteid), wake = wake)
	def remove_sprite(self, spriteid):
		wake = (yield)
		yield from serverdata.delete('sprite', ('=', 'id', spriteid), wake = wake)
	# }}}
	# Images {{{
	def _list_images(self, wake):
		data = (yield from serverdata.select('image', ('id', 'sprite', 'mood', 'width', 'height', 'hotx', 'hoty'), wake = wake))
		return {d[0]: {'sprite': d[1], 'mood': d[2], 'size': (d[3], d[4]), 'hotspot': (d[5], d[6])} for d in data}
	def list_images(self):
		wake = (yield)
		return (yield from self._list_images(wake))
	def _get_image(self, wake, imageid):
		data = (yield from serverdata.select('image', ('url', 'sprite', 'mood', 'width', 'height', 'hotx', 'hoty'), ('=', 'id', imageid), wake = wake))
		return None if len(data) == 0 else {'url': data[0][0], 'sprite': data[0][1], 'mood': data[0][2], 'size': [data[0][3], data[0][4]], 'hotspot': [data[0][5], data[0][6]]}
	def get_image(self, imageid):
		wake = (yield)
		return (yield from self._get_image(wake, imageid))
	def _add_image(self, wake, imageid, sprite, mood, url, size, hotspot):
		# TODO: load image and detect size.
		yield from serverdata.insert('image', {'id': imageid, 'sprite': sprite, 'mood': mood, 'url': url, 'width': size[0], 'height': size[1], 'hotx': hotspot[0], 'hoty': hotspot[1]}, wake = wake)
	def add_image(self, imageid, sprite, mood, url, size, hotspot):
		wake = (yield)
		yield from self._add_image(wake, imageid, sprite, mood, url, size, hotspot)
	def update_image(self, imageid, sprite, mood, url, size, hotspot):
		wake = (yield)
		# TODO: load image and detect size.
		if url is None:
			yield from serverdata.update('image', {'sprite': sprite, 'mood': mood, 'width': size[0], 'height': size[1], 'hotx': hotspot[0], 'hoty': hotspot[1]}, ('=', 'id', imageid), wake = wake)
		else:
			yield from serverdata.update('image', {'sprite': sprite, 'mood': mood, 'url': url, 'width': size[0], 'height': size[1], 'hotx': hotspot[0], 'hoty': hotspot[1]}, ('=', 'id', imageid), wake = wake)
	def remove_image(self, imageid):
		wake = (yield)
		yield from serverdata.delete('image', ('=', 'id', imageid), wake = wake)
	# }}}
	# Audio {{{
	def _list_audio(self, wake):
		data = (yield from serverdata.select('audio', ('id', 'duration'), wake = wake))
		return {d[0]: {'duration': d[1]} for d in data}
	def list_audio(self):
		wake = (yield)
		return (yield from self._list_audio(wake))
	def _get_audio(self, wake, audioid):
		data = (yield from serverdata.select('audio', ('url',), ('=', 'id', audioid), wake = wake))
		return None if len(data) == 0 else data[0][0]
	def get_audio(self, audioid):
		wake = (yield)
		return (yield from self._get_audio(wake, audioid))
	def _add_audio(self, wake, audioid, url, duration):
		# TODO: load sound and detect duration.
		yield from serverdata.insert('audio', {'id': audioid, 'url': url, 'duration': duration}, wake = wake)
	def add_audio(self, audioid, url, duration):
		wake = (yield)
		return (yield from self._add_audio(wake, audioid, url, duration))
	def update_audio(self, audioid, url, duration):
		wake = (yield)
		# TODO: load sound and detect duration.
		if url is None:
			yield from serverdata.update('audio', {'duration': duration}, ('=', 'id', audioid), wake = wake)
		else:
			yield from serverdata.update('audio', {'url': url, 'duration': duration}, ('=', 'id', audioid), wake = wake)
	def remove_audio(self, audioid):
		wake = (yield)
		yield from serverdata.delete('audio', ('=', 'id', audioid), wake = wake)
	# }}}
	def import_chapter(self, zipdata): # {{{
		wake = (yield)
		z = zipfile.ZipFile(io.BytesIO(base64.b64decode(zipdata)), 'r')
		for info in z.infolist():
			parts = info.filename.split('/')
			if parts[1] == 'sprite':
				if len(parts) != 4:
					print('ignoring unknown path in imported zipfile: %s' % parts[1], file = sys.stderr)
					continue
				if parts[2] not in sprites:
					yield from self._add_sprite(wwake)
			if len(parts) != 3:
				print('ignoring path in imported zipfile, because it does not have 3 parts: %s' % info.filename)
				continue
			if parts[1] == 'script':
				yield from self._add_script(wake, parts[2], parent, z.read(info).decode('utf-8', 'replace'))
			elif parts[1] == 'audio':
				yield from self._add_audio(wake, parts[2], z.read(info), 0)
			elif parts[1] == 'video':
				print('ignoring video path in imported zipfile (not implemented yet)', file = sys.stderr)
			else:
				print('ignoring unknown path in imported zipfile: %s' % parts[1], file = sys.stderr)
	# }}}
	def export_chapter(self, chapterid): # {{{
		wake = (yield)
		chaptername = (yield from serverdata.select('chapter', ('name',), ('=', 'id', chapterid), wake = wake))
		ret = io.BytesIO()
		z = zipfile.ZipFile(ret, 'w')
		images = {}
		info = b''
		for imageid, im in (yield from self._list_images(wake)).items():
			if im['sprite'] not in images:
				images[im['sprite']] = {}
			images[im['sprite']][im['mood']] = {'id': imageid, 'size': im['size'], 'hotspot': im['hotspot']}
		for spriteid, sprite in (yield from self._list_sprites(wake)).items():
			if sprite['chapter'] != chapterid:
				continue
			info += b'sprite %s\n' % sprite['name']
			for mood in images[spriteid]:
				imageid = images[spriteid][mood]['id']
				url = (yield from self._get_image(wake, imageid))
				with z.open('%s/%s/%s' % (chaptername, sprite['name'], mood + '.txt'), 'w') as f:
					f.write(url.encode('utf-8'))
				info += b'mood %s size %f %f hotspot %f %f\n' % (mood, images[spriteid][mood]['size'][0], images[spriteid][mood]['size'][1], images[spriteid][mood]['hotspot'][0], images[spriteid][mood]['hotspot'][1])
		for audioid, duration in (yield from self._list_audio(wake)).items():
			data = (yield from self._get_audio(wake, audioid))
			if data is None:
				print('ignoring invalid audio id %s' % audioid)
				continue
			with z.open('%s/audio/%s' % (chaptername, audioid), 'w') as f:
				f.write(data)
		with z.open('%s/info.txt' % chaptername, 'w') as f:
			f.write(info)
		z.close()
		return 'data:application/zip;base64,' + base64.b64encode(ret.getbuffer()).decode('utf-8')
	# }}}
# }}}

class Connection: # {{{
	# Internals. {{{
	def __init__(self, my_id, my_name, my_userdata, my_remote, managed_name): # {{{
		self.id = my_id
		self.name = my_name
		self.userdata = my_userdata
		self.remote = my_remote
		self.manged_name = managed_name
		self.display_name = my_name + (' (%s)' % managed_name if managed_name is not None else '')
		self.new_commands = None	# This is initialized to a list when running code and filled with new commands by it.
	# }}}
	def _close(self): # {{{
		wake = (yield)
		del users[self.id]
		yield from refresh_admins(wake)
	# }}}
	def _init(self, wake): # {{{
		# Delayed contructor. Must be a generator.
		self._websocket_closed = self._close
		self.busy = False
		debug(2, 'New connection from {}:{}'.format(*self.remote.socket.remote))
		u = {}
		users[self.id] = u
		u['connection'] = self
		self.user = u
		data = (yield from self.userdata.select('id', ('my_name', 'my_group'), wake = wake))
		if len(data) == 0:
			groupname = (yield from serverdata.select('group', ('name',), ('=', 'id', 1), wake = wake))
			if len(groupname) == 0:
				groupname = ['']
			yield from self.userdata.insert('id', {'my_name': self.name, 'my_group': groupname[0][0]}, wake = wake)
			my_group = 1
		else:
			self.name = data[0][0]
			g = (yield from serverdata.select('group', ('id',), ('=', 'name', data[0][1]), wake = wake))
			if len(g) != 1:
				my_group = 1
			else:
				my_group = g[0][0]
		debug(1, 'User {}:{} logged in from {}:{}'.format(self.name, my_group, *self.remote.socket.remote))
		u['name'] = self.name
		u['group'] = my_group
		u['program'] = []
		u['run_stack'] = []
		u['chapter'] = None	# Current chapter.
		u['question'] = None	# Question that is currently being asked.
		scripts = (yield from content.list(wake, my_group))
		u['chapterprefix'] = []
		if len(scripts) > 0:
			while len(scripts[0]) > 1 and all(x[0] == scripts[0][0] for x in scripts):
				u['chapterprefix'].append(scripts[0][0])
				for s in scripts:
					s.pop(0)
		self.remote.contents.event(scripts)
		self.remote.main.event(self.display_name)
		yield from refresh_admins(wake)
	# }}}
	def _finish_login(self, wake = None): # {{{
		# TODO: This function is never called anymore. It should be called when (managed?) players reconnect.
		if wake is None:
			wake = (yield)
		if self.user['chapter'] is not None:
			if len(self.user['run_stack']) > 0 and len(self.user['run_stack'][-1]['program']) > 1:
				setup = []
				state = self.user['_kinetic_state']
				if state['background'] is not None:
					setup.append({'action': 'scene', 'target': state['background'], 'args': {'with': None}})
				for spr in state['sprite']:
					s = state['sprite'][spr]
					arg = {'action': 'move', 'target': spr, 'image': s['image']}
					arg.args = {x: s[x] for x in ('from', 'from_hotspot', 'to', 'to_hotspot', 'scale', 'scale_hotspot', 'rotation', 'rotation_hotspot')}
					arg.args.update({'with': None, 'around': None, 'in': None})
					setup.append(arg)
				self.remote.kinetic.event(setup, state['music'])
				if not (yield from self._run_item(wake, self.user['run_stack'][-1]['program'][self.user['run_stack'][-1]['current']])):
					debug(0, 'Bug: saved state of user {}:{} was not a waiting state'.format(name, group))
					yield from self._run(wake)
	# }}}
	def _safe_eval(self, expr, as_str): # {{{
		'Evaluate an expression through Lua.'
		ret = self.user['environment'].compute(expr, as_str)
		return str(ret) if as_str else ret
	# }}}
	def _parse_text(self, text): # {{{
		'Do substitutions on a text that is going to be shown to the user. This should be called with "yield from".'
		if text is None:
			return None
		result = ''
		for m in re.finditer('\${(.*?)}|[^$]+', text):
			if m.group(1) is None:
				# This is not a substitution; add the string to the result.
				result += m.group(0)
			else:
				# This is a substitution; add the evaluated string to the result.
				result += self._safe_eval(m.group(1), as_str = True)
		return result
	# }}}
	def _parse_time(self, wake, t): # {{{
		'Parse a string (possibly including substitutions) as a time. Units of s for seconds or ms for milliseconds are required. This should be called with "yield from".'
		i = self._parse_text(t).strip()
		r = re.match(r'([-+.e0-9]+)\s*(m?)s$', i)
		if r is None:
			return None
		else:
			try:
				num = float(r.group(1))
				if r.group(2) == 'm':
					num /= 1e3
				return num
			except ValueError:
				debug(0, 'error parsing time {}'.format(i))
				return None
	# }}}
	def _answer(self, wake, style): # {{{
		'''Set style for last answer. This should be called with "yield from".'''
		if self.user['question'] is None:
			debug(1, 'answer style given before a question was answered')
			return
		style = self._parse_text(style)
		yield from self.userdata.update('answer', {'style': style}, ('and', ('=', 'question', self.user['question']), ('=', 'script', self.user['scripttag'])), wake = wake)
		yield from refresh_admins(wake)
	# }}}
	def _home(self, wake): # {{{
		self.user['chapter'] = None
		del self.user['environment']
		yield from refresh_admins(wake)
		self.remote.main.event(self.display_name)
	# }}}
	def _clear_pending(self): # {{{
		# update kinetic state.
		def handle_action(action, state):
			if action['action'] in ('speech', 'sound', 'wait'):
				# Nothing to update.
				pass
			elif action['action'] == 'scene':
				state['background'] = action['target']
			elif action['action'] == 'music':
				state['music'] = action['target']
			elif action['action'] in ('serial', 'parallel'):
				for a in action['actions']:
					handle_action(a, state)
			elif action['action'] == 'hide':
				del state['sprite'][action['target']]
			else:
				assert action['action'] == 'move'

				# If target sprite does not exist, create it (with no image).
				if action['target'] not in state['sprite']:
					state['sprite'][action['target']] = {'from': [0, 0, None], 'from_hotspot': None, 'to': [0, 0, None], 'to_hotspot': None, 'scale': None, 'scale_hotspot': None, 'rotation': None, 'rotation_hotspot': None, 'image': None}
				# Store target sprite in local variable.
				target = state['sprite'][action['target']]

				# Set mood image.
				target['target'] = action['target']
				target['mood'] = action['mood']
				args = action['args']
				for prop in ('from', 'from_hotspot', 'to', 'to_hotspot', 'scale', 'scale_hotspot', 'rotation', 'rotation_hotspot'):
					if args.get(prop) is not None:
						target[prop] = args[prop]
		for action in self.user['_pending']:
			handle_action(action, self.user['_kinetic_state'])
		#debug(0, repr(self.user['_pending']))
		self.user['_pending'] = []
	# }}}
	def _start(self, wake, script_content, send_errors): # {{{
		self.user['program'], errors, question = script_content
		if send_errors:
			if len(errors) > 0:
				errors = markdown('# Errors:\n' + '\n\n'.join(errors))
			else:
				errors = ''
			self.remote.error.event(errors)
		self.user['run_stack'] = [{'program': self.user['program'], 'current': 0}]
		# Sprites are stored in two steps.
		# All available sprites are loaded into user['sprite'] by this function.
		# All active sprites (declared with a "sprite" command, may or may not be onscreen) are in user['activesprite']. Both are dicts.
		# user['sprite'] has sprite names (as defined in db) as keys. Its values are dicts with mood names as keys and their numerical image ids as values.
		# user['activesprite'] has tags as used in the script as keys. Its values are dicts with items:
		#   'name': The character's name that is shown on screen as the speaker name,
		#   'id': The db sprite name, which is used as the key in user['sprite'] and
		#   'mood': The currently active mood, for when there is speech without an explicit mood.
		self.user['sprite'] = {}
		self.user['activesprite'] = {}
		self.user['_pending'] = []
		self.user['question'] = None
		# Set up self.user['sprite']. {{{
		global_sprites = (yield from serverdata.select('sprite', ('id', 'name'), ('=', 'chapter', None), wake = wake))
		local_sprites = (yield from serverdata.select('sprite', ('id', 'name'), ('=', 'chapter', self.user['chapter']), wake = wake))
		spriteid = {name: id for id, name in global_sprites}
		spriteid.update({name: id for id, name in local_sprites})
		for name in spriteid:
			id = spriteid[name]
			moods = (yield from serverdata.select('image', ('mood', 'id'), ('=', 'sprite', id), wake = wake))
			self.user['sprite'][name] = {m[0]: m[1] for m in moods}
		sprites = {name: list(self.user['sprite'][name].keys()) for name in spriteid}
		# }}}
		self.user['environment'] = Environment()
		self.user['environment'].set('name', self.user['name'])
		self.user['environment'].set('group', self.user['group'])
		self.user['environment'].set('chapter', self.user['chapter'])
		self.user['environment'].set('script', self.user['script'])
		self.user['environment'].set('sprites', sprites);	# Available sprites (and moods).
		self.user['environment'].set('sprite', self.user['activesprite']);	# Active sprites.
		startup = fhs.read_data(os.path.join('include', 'startup.lua'))
		if startup is not None:
			try:
				self.user['environment'].run(startup.read(), False)
			except:
				debug(1, 'Error in startup script')
				traceback.print_exc()
		yield from self._run(wake)
	# }}}
	def _question(self, qtype, last_answer, markdown, options): # {{{
		if qtype == 'unit':
			qtype = 'short'
		if qtype == 'longunit':
			qtype = 'longshort'
		qtext = self._parse_text(markdown)
		parsed_options = []
		if options is not None:
			for x in options:
				parsed_options.append(self._parse_text(x))
		self.remote.question.event(self.user['_pending'], qtext, qtype, parsed_options, last_answer)
		self.breaking = True
		return True
	# }}}
	def _run(self, wake): # {{{
		watchdog = 0
		while len(self.user['run_stack']) > 0:
			watchdog += 1
			if watchdog > 1000:
				debug(1, 'hanging script detected: {}; killing it'.format(self.user['chapter']))
				self.remote.error.event(['Script stopped working and was killed.'])
				self.user['run_stack'] = [{'program': self.user['program'], 'current': len(self.user['program'])}]
				yield from refresh_admins(wake)
				return
			# Pop off stack levels until there's an instruction.
			while len(self.user['run_stack'][-1]['program']) <= self.user['run_stack'][-1]['current']:
				self.user['run_stack'].pop()
				#print('pop', self.user['run_stack'])
				if len(self.user['run_stack']) == 0:
					# Send final "question".
					self.remote.question.event(self.user['_pending'], '', 'choice', ['Done'])
					self.breaking = True
					yield from refresh_admins(wake)
					return
			# Run instructions.
			if (yield from self._run_item(wake, self.user['run_stack'][-1]['program'][self.user['run_stack'][-1]['current']])):
				#print('break')
				break
			#print('no break')
		yield from refresh_admins(wake)
	# }}}
	def _run_item(self, wake, code): # {{{
		debug(3, '{}:{} running item {}'.format(self.user['name'], self.user['group'], repr(code)))
		if code['command'] == 'label': # {{{
			pass
		# }}}
		elif code['command'] == 'answer': # {{{
			yield from self._answer(wake, code['answer'])
		# }}}
		elif code['command'] == 'if': # {{{
			self.user['run_stack'][-1]['current'] += 1
			for expr, target in code['code']:
				if expr is None or self._safe_eval(expr, as_str = False):
					self.user['run_stack'].append({'program': target, 'current': 0})
					break
			return False
		# }}}
		elif code['command'] == 'while': # {{{
			# Don't increment instruction pointer, so the loop restarts.
			if self._safe_eval(code['test'], as_str = False):
				self.user['run_stack'].append({'program': code['code'], 'current': 0})
			else:
				# exit the while loop.
				self.user['run_stack'][-1]['current'] += 1
				# handle else clause, if present.
				if code['else'] is not None:
					self.user['run_stack'].append({'program': code['else'], 'current': 0})
			return False
		# }}}
		elif code['command'] in ('continue', 'break'): # {{{
			while self.user['run_stack'][-1]['current'] >= len(self.user['run_stack'][-1]['program']) or self.user['run_stack'][-1]['program'][self.user['run_stack'][-1]['current']]['command'] != 'while':
				self.user['run_stack'].pop()
			if code['command'] == 'break':
				self.user['run_stack'][-1]['current'] += 1
			return False
		# }}}
		elif code['command'] == 'goto': # {{{
			# Break to top level and jump to requested label.
			while len(self.user['run_stack']) > 1:
				self.user['run_stack'].pop()
			self.user['run_stack'][-1]['current'] = code['target']
			return False
		# }}}
		elif code['command'] == 'code': # {{{
			self.breaking = False
			self.user['run_stack'][-1]['current'] += 1	# Do this before running the code, so goto works.
			try:
				self.new_commands = []
				self.user['environment'].run(code['code'])
				if len(self.new_commands) > 0:
					self.user['run_stack'].append({'program': self.new_commands, 'current': 0})
			except:
				debug(0, 'Error in script: {}'.format(code['code']))
				traceback.print_exc()
				self.remote.error.event(code['code'])
			finally:
				self.new_commands = None
			return self.breaking
		# }}}
		elif code['command'] == 'video': # {{{
			self.remote.video.event(self.user['_pending'], code['video'])
			return True
		# }}}
		elif code['command'] == 'sprite': # {{{
			self.user['activesprite'][code['tag']] = {'name': self._parse_text(code['name']), 'id': self._parse_text(code['images']), 'mood': ''}
		# }}}
		elif code['command'] == 'kinetic': # {{{
			def build_kinetic(wake, item): # {{{
				if item['action'] == 'speech': # {{{
					target = item['speaker']
					#print('check', item, self.user['activesprite'])
					speaker = None if target is None else self.user['activesprite'][target]['name'] if target in self.user['activesprite'] else '(' + target + ')'
					if target in self.user['activesprite']: # {{{
						# Target is an active sprite (defined in the script).
						spriteid = self.user['activesprite'][target]['id']
						if spriteid in self.user['sprite']: # {{{
							# Target is a sprite (not an invalid active sprite).
							sprite = self.user['sprite'][spriteid]
							if item['mood'] not in sprite: # {{{
								# Requested mood does not exist.
								mood = None
							else:
								# Requested mood exists; use it.
								mood = item['mood']
							# }}}
						else:
							# Target is not a sprite (invalid name defined in script): no images.
							mood = None
						# }}}
					else:
						# Target is not an active sprite (not defined in script): no images.
						mood = None
					# }}}
					if 'side' in self.user['activesprite'][target]:
						side = self.user['activesprite'][target]['side']
					else:
						side = None
					return {'action': 'speech', 'speaker': speaker, 'target': target, 'mood': mood, 'side': side, 'text': markdown(self._parse_text(item['markdown']))}
				# }}}
				if item['action'] == 'wait': # {{{
					return {'action': 'wait', 'time': self._parse_time(wake, item['time'])}
				# }}}
				if item['action'] in ('sound', 'music'): # {{{
					target = None if item['target'] is None else self._parse_text(item['target'])
					return {'action': item['action'], 'target': target}
				# }}}
				if item['action'] in ('serial', 'parallel'): # {{{
					actions = []
					for x in item['actions']:
						actions.append((yield from build_kinetic(wake, x)))
					return {'action': item['action'], 'args': item['args'], 'actions': actions}
				# }}}
				# Something else: move, or hide.
				args = {}
				# Parse animation arguments. {{{
				def parse_location(loc): # {{{
					'Parse location; return location and hotspot'
					if loc is None:
						return None, [0, 0]
					raw = self._parse_text(loc)
					if '@' in raw:
						h, pos = loc.split('@')
						hotspot = [float(x) for x in h.split(',')]
					else:
						pos = loc
						hotspot = [None, None]
					l = [x.strip() for x in pos.split(',')]
					h = [None, None]
					if l[0] == 'outleft':
						l[0] = -1
						h[0] = 1
					elif l[0] == 'inleft':
						l[0] = -1
						h[0] = -1
					elif l[0] == 'outright':
						l[0] = 1
						h[0] = -1
					elif l[0] == 'inright':
						l[0] = 1
						h[0] = 1
					elif l[0] == 'left':
						l[0] = -.4
						h[0] = 0
					elif l[0] == 'center':
						l[0] = 0
						h[0] = 0
					elif l[0] == 'right':
						l[0] = .4
						h[0] = 0
					else:
						try:
							l[0] = float(l[0])
						except:
							l[0] = 0
					if hotspot[0] is not None:
						h[0] = hotspot[0]
					if len(l) == 1:
						l.append(None)
					elif l[1] == 'outbottom':
						l[1] = 0
						h[1] = 1
					elif l[1] == 'inbottom':
						l[1] = 0
						h[1] = -1
					elif l[1] == 'outtop':
						l[1] = 1
						h[1] = -1
					elif l[1] == 'intop':
						l[1] = 1
						h[1] = 1
					elif l[1] == 'bottom':
						l[1] = 0
						h[1] = 0
					elif l[1] == 'low':
						l[1] = .2
						h[1] = 0
					elif l[1] == 'middle':
						l[1] = .5
						h[1] = 0
					elif l[1] == 'high':
						l[1] = .8
						h[1] = 0
					elif l[1] == 'top':
						l[1] = 1
						h[1] = 0
					else:
						try:
							l[1] = float(l[1])
						except:
							l[1] = None
					if hotspot[1] is not None:
						h[1] = hotspot[1]
					if len(l) == 2:
						l.append(None)
					else:
						try:
							l[2] = int(l[2])
						except:
							l[2] = None
					if h == [None, None]:
						h = None
					return l, h
				# }}}
				def parse_around(loc): # {{{
					if loc is None:
						return None
					l = [x.strip() for x in self._parse_text(loc).split()]
					if l[-1] in ('cw', 'ccw'):
						cw = l[-1] == 'cw'
						l.pop()
					else:
						cw = False
					if l[0] == 'left':
						l[0] = -.4
					elif l[0] == 'center':
						l[0] = 0
					elif l[0] == 'right':
						l[0] = .4
					else:
						try:
							l[0] = float(l[0])
						except:
							l[0] = 0
					if len(l) == 1:
						l.append(0)
					elif l[1] == 'bottom':
						l[1] = 0
					elif l[1] == 'low':
						l[1] = .2
					elif l[1] == 'middle':
						l[1] = .5
					elif l[1] == 'high':
						l[1] = .8
					elif l[1] == 'top':
						l[1] = 1
					else:
						try:
							l[1] = float(l[1])
						except:
							l[1] = 0
					return l[:2] + [cw]
				# }}}
				if item['args']['in'] is None: # {{{
					args['in'] = None
				else:
					args['in'] = self._parse_time(wake, item['args']['in'])
				# }}}
				args['to'], args['to_hotspot'] = parse_location(item['args']['to'])
				if args['in'] is None:
					args['with'] = 'jump'
					args['from'], args['from_hotspot'] = args['to'], args['to_hotspot']
				else:
					args['from'], args['from_hotspot'] = parse_location(item['args']['from'])
				if args['from'] is not None:
					if args['from'][0] is None:
						args['from'][0] = 0
					if args['from'][1] is None:
						args['from'][1] = 0
				if item['args']['with'] is None: # {{{
					args['with'] = 'move'
				else:
					w = self._parse_text(item['args']['with'])
					if w not in ('jump', 'fade', 'move'):
						debug(0, 'invalid transition {}'.format(w))
						args['with'] = None
					else:
						args['with'] = w
				# }}}
				args['around'] = parse_around(item['args']['around'])
				if item['args']['scale'] is None: # {{{
					args['scale'] = None
					args['scale_hotspot'] = None
				else:
					raw = self._parse_text(item['args']['scale'])
					if '@' in raw:
						value, hotspot = raw.split('@')
						s = [x.strip() for x in value.split(',')]
						h = [x.strip() for x in hotspot.split(',')]
					else:
						s = [x.strip() for x in raw.split(',')]
						h = None
					try:
						def parse(num):
							if num.endswith('%'):
								return float(num[:-1]) / 100
							return float(num)
						s = [parse(x) for x in s]
						if len(s) == 1:
							s.append(s[0])
						elif len(s) > 2:
							s = [s[0], s[1]]
					except:
						debug(0, 'error parsing scale {}'.format(s))
						s = None
					args['scale'] = s
					args['scale_hotspot'] = h
				# }}}
				if item['args']['rotation'] is None: # {{{
					args['rotation'] = None
					args['rotation_hotspot'] = None
				else:
					raw = self._parse_text(item['args']['rotation']).strip()
					if '@' in raw:
						r, hotspot = raw.split('@')
						h = [x.strip() for x in hotspot.split(',')]
					else:
						r = raw
						h = None
					if r.endswith('°'):
						f = 360
						r = r[:-1]
					else:
						f = 1
					try:
						r = float(r) / f
					except:
						debug(0, 'error parsing rotation {}'.format(r))
						r = None
					args['rotation'] = r
					args['rotation_hotspot'] = h
				# }}}
				if item['target'] is None: # {{{
					target = None
					mood = None
				else:
					target = self._parse_text(item['target'])
					mood = self._parse_text(item['mood'])
				# }}}
				# }}}
				#print('returning build', item['action'])
				return {'action': item['action'], 'target': target, 'mood': mood, 'args': args}
			# }}}
			actions = []
			for x in code['kinetic']:
				#print('building', x)
				actions.append((yield from build_kinetic(wake, x)))
			self.user['_pending'].extend(actions)
			#print('now pending:', self.user['_pending'])
		# }}}
		elif code['command'] == 'question': # {{{
			if code['type'] == 'hidden':
				self._store_answer(code['variable'], self._safe_eval(code['markdown'], as_str = True))
			else:
				# Question.
				answers = (yield from self.userdata.select('answer', ('answer',), ('and', ('=', 'script', self.user['scripttag']), ('=', 'question', code['variable'])), wake = wake))
				if len(answers) == 0:
					last_answer = None
				else:
					last_answer = json.loads(answers[-1][0])
				#print('sending question', code['type'])
				return self._question(code['type'], last_answer, code['markdown'], code['option'])
		else:
			debug(0, 'invalid command {}'.format(code))
		# }}}
		self.user['run_stack'][-1]['current'] += 1
		return False
	# }}}
	def _update_sprite(self, tag, data): # {{{
		for item in ('x', 'y', 'mood'):
			if item in data:
				self.user['characters'][tag][item] = data[item]
		c = self.user['characters'][tag]
		data['url'] = c['imgs'] + (data.pop('mood') if 'mood' in data else 'default') + c['ext']
	# }}}
	def _store_answer(self, question, answer, store = True): # {{{
		self.user['environment'].set(question, answer)
		if store:
			self.userdata.insert('answer', {'script': self.user['scripttag'], 'question': question, 'answer': json.dumps(answer)})
			self.user['question'] = question
		else:
			self.user['question'] = None
	# }}}
	# }}}
	def get_sprite_image(self, sprite_tag, sprite_mood): # {{{
		'Retrieve image from database. Return data url.'
		wake = (yield)
		#print('getting image for sprite', repr(sprite_tag), repr(sprite_mood))
		if sprite_tag in self.user['activesprite']:
			sprite_name = self.user['activesprite'][sprite_tag]['id']
		else:
			sprite_name = sprite_tag
		if sprite_name in self.user['sprite']:
			if sprite_mood in self.user['sprite'][sprite_name]:
				imageid = self.user['sprite'][sprite_name][sprite_mood]
			elif '' in self.user['sprite'][sprite_name]:
				imageid = self.user['sprite'][sprite_name]['']
			else:
				imageid = None
		else:
			s = self.user['sprite']['']
			if sprite_mood in s:
				imageid = s[sprite_mood]
			elif '' in s:
				imageid = s['']
			else:
				imageid = None
		data = (yield from serverdata.select('image', ('url', 'width', 'height', 'hotx', 'hoty'), ('=', 'id', imageid), wake = wake))
		if len(data) != 1:
			print('Warning: sprite %s mood %s not found and no fallback found either' % (sprite_tag, sprite_mood))
			return {'url': None, 'size': (0, 0), 'hotspot': (0, 0)}
		#print('image id', imageid, 'from', repr(self.user['sprite']), 'data', data[0][0][:30])
		return {'url': data[0][0], 'size': (data[0][1], data[0][2]), 'hotspot': (data[0][3], data[0][4])}
	# }}}
	def get_audio(self, audioid): # {{{
		'Retrieve audio from database. Return data url.'
		wake = (yield)
		data = (yield from serverdata.select('audio', ('url', 'duration'), ('=', 'id', audioid), wake = wake))
		if len(data) != 1:
			log('failed to get audio %s' % audioid)
			return None
		return {'url': data[0][0], 'duration': data[0][1]}
	# }}}
	def home(self): # {{{
		wake = (yield)
		if self.busy and not force:
			traceback.print_stack()
			log('attempt to home while busy')
			return
		yield from self._home(wake)
	# }}}
	def start(self, script): # {{{
		wake = (yield)
		if self.busy:
			log('attempt to start while busy')
			traceback.print_stack()
			return
		self.user['_kinetic_state'] = {'background': None, 'sprite': {}, 'music': None}
		self.busy = True
		chapterid, scriptid, code = (yield from content.get(wake, self.user['group'], self.user['chapterprefix'] + script))
		self.user['scripttag'] = '\t'.join(script)
		self.user['chapter'] = chapterid
		self.user['script'] = scriptid
		try:
			yield from self._start(wake, code, False)
		finally:
			self.busy = False
	# }}}
	def answer(self, answer): # {{{
		wake = (yield)
		if self.busy:
			log('attempt to answer while busy')
			return
		self._clear_pending()
		debug(3, '{}:{} answers {}'.format(self.user['name'], self.user['group'], answer))
		if len(self.user['run_stack']) == 0:
			# Ignore answer for final "Done" button.
			yield from self._home(wake)
			return
		if self.user['run_stack'][-1]['current'] >= len(self.user['run_stack'][-1]['program']):
			self.busy = True
			try:
				yield from self._run(wake)
			finally:
				self.busy = False
			return
		current = self.user['run_stack'][-1]['program'][self.user['run_stack'][-1]['current']]
		if current['type'] not in ('short', 'long', 'choice', 'unit', 'longshort', 'longunit', 'longchoice'):
			debug(1, 'answer given by {}:{} for non-question: {}'.format(self.remote.socket.remote[0], self.remote.socket.remote[1], current))
			return
		store = not current['variable'].startswith('_')
		def parse_unit(src):
			r = re.match(r'\s*(?:(\S+)\s*=\s*)?([+-]?[0-9]*(?:[.,]\d*)?)(?:·10([⁻⁺]?[⁰¹²³⁴⁵⁶⁷⁸⁹]+))?\s*(\S*)\s*$', src)
			# groups:
			# 1: quantity	(\S+)
			# 2: base value	([+-]?[0-9]*(?:[.,]\d*)?)
			# 3: exponent	(·10([⁻⁺]?[⁰¹²³⁴⁵⁶⁷⁸⁹]+))?
			# 4: unit	(\S*)
			if not r or r.group(1) is None:
				debug(3, 'no match for unit answer')
				answer = {'quantity': None, 'unit': None, 'digits': None, 'value': None}
			else:
				try:
					answer = {}
					answer['quantity'] = r.group(1)
					base = r.group(2).replace(',', '.')
					exponent = None if r.group(3) is None else int(fromsuper(r.group(3)))
					answer['unit'] = r.group(4)
					answer['digits'] = len(base.replace('.', '').lstrip('0'))
					answer['value'] = float(base) * (1 if exponent is None else 10 ** exponent)
				except:
					traceback.print_exc()
					answer = {'quantity': None, 'unit': None, 'digits': None, 'value': None}
			debug(3, 'unit-split answer: {}'.format(answer))
			return answer
		raw = answer
		if current['type'] == 'choice':
			if isinstance(answer, int) and 1 <= answer <= len(current['option']):
				answer = {'index': answer, 'text': current['option'][answer - 1]}
			else:
				answer = {}
			if len(current['option']) <= 1:
				store = False
		elif current['type'] == 'longchoice':
			if isinstance(answer[0], int) and 1 <= answer[0] <= len(current['option']):
				answer = {'index': answer[0], 'text': current['option'][answer[0] - 1], 'long': str(answer[1]).strip()}
			else:
				# Leave answer string as is (but force str); this only happens when users are messing with the js.
				debug(2, 'unparsable longchoice answer: {}'.format(answer))
				answer = {'choice': None, 'long': str(answer).strip()}
		elif current['type'] == 'unit':
			answer = parse_unit(answer)
		elif current['type'] == 'longunit':
			l = answer[1]
			try:
				answer = parse_unit(answer[0])
				answer['long'] = l
			except:
				# Leave answer string as is (but force str); this only happens when users are messing with the js.
				debug(2, 'unparsable longunit answer: {}'.format(answer))
				answer = {}
		elif current['type'].startswith('long') and current['type'] != 'long':
			try:
				answer = {'text': str(answer[0]).strip(), 'long': str(answer[1]).strip()}
			except:
				# Leave answer string as is (but force str); this only happens when users are messing with the js.
				debug(2, 'unparsable long* answer: {}'.format(answer))
				answer = {}
		else:
			answer = {'text': answer}
		answer['raw'] = raw
		answer['style'] = []
		self._store_answer(current['variable'], answer, store)
		self.user['run_stack'][-1]['current'] += 1
		self.busy = True
		try:
			yield from self._run(wake)
		finally:
			self.busy = False
	# }}}
	def video_done(self): # {{{
		wake = (yield)
		if self.busy:
			log('attempt to finish video while busy')
			return
		self._clear_pending()
		if self.user['run_stack'][-1]['current'] >= len(self.user['run_stack'][-1]['program']):
			self.busy = True
			try:
				yield from self._run(wake)
			finally:
				self.busy = False
			return
		current = self.user['run_stack'][-1]['program'][self.user['run_stack'][-1]['current']]
		if current[0] == 'video':
			self.user['run_stack'][-1]['current'] += 1
			self.busy = True
			try:
				yield from self._run(wake)
			finally:
				self.busy = False
	# }}}
# }}}

def connection_selector(my_id, my_name, my_userdata, my_remote, managed_name): # {{{
	parts = my_remote.data['url'].strip('/').split('/')
	# example parts: ['content', 'index.html', 'websocket']
	if len(parts) > 2:
		if parts[-3] == 'admin':
			return Admin_Connection(my_id, my_name, my_userdata, my_remote, managed_name)
		if parts[-3] == 'content':
			return Content_Connection(my_id, my_name, my_userdata, my_remote, managed_name)
	return Connection(my_id, my_name, my_userdata, my_remote, managed_name)
# }}}

db_config = { # {{{
	# Permissions # {{{
	'group': [
		('id', 'int(11) NOT NULL AUTO_INCREMENT PRIMARY KEY'),
		('name', 'text NOT NULL')
	],
	'chapter': [
		('id', 'int(11) NOT NULL AUTO_INCREMENT PRIMARY KEY'),
		('name', 'text NOT NULL'),
		('parent', 'int(11) DEFAULT NULL'),
	],
	'access': [
		('groupid', 'int(11) NOT NULL'),
		('chapter', 'int(11) DEFAULT NULL'),
	],
	# }}}

	# Scripts {{{
	'script': [
		('id', 'int(11) NOT NULL AUTO_INCREMENT PRIMARY KEY'),
		('name', 'text NOT NULL'),
		('chapter', 'int(11) NOT NULL'),
		('script', 'longtext NOT NULL')
	],
	'question': [
		('id', 'text NOT NULL'),
		('script', 'int(11) NOT NULL'),
		('type', 'varchar(255) NOT NULL'),
		('description', 'varchar(255) NOT NULL')
	],
	# }}}

	# Images {{{
	'sprite': [
		('name', 'text NOT NULL'),	# Sprite name.
		('chapter', 'int(11) DEFAULT NULL'),	# Chapter id, or NULL for global sprites.
		('id', 'int(11) NOT NULL AUTO_INCREMENT UNIQUE'),	# Sprite id.
	],
	'image': [
		('id', 'int(11) NOT NULL AUTO_INCREMENT PRIMARY KEY'),
		('sprite', 'int(11) NOT NULL'),	# Sprite id.
		('mood', 'text NOT NULL'),	# Mood name.
		('url', 'longtext NOT NULL'),	# Data url.

		# Size of image in screen units.
		('width', 'float NOT NULL'),
		('height', 'float NOT NULL'),

		# Location of hotspot in screen units.
		# The origin for the hotspot coordinates is the bottom left corner of the image.
		('hotx', 'float NOT NULL'),
		('hoty', 'float NOT NULL'),
	],
	# }}}

	# Media {{{
	'audio': [
		('id', 'varchar(255) NOT NULL PRIMARY KEY'),
		('url', 'longtext NOT NULL'),	# Data url.
		('duration', 'int(11) NOT NULL'),
	],
	# }}}
} # }}}
player_config = { # {{{
	'id': [	# This table has only one row.
		('my_name', 'varchar(255) NOT NULL'),
		('my_group', 'varchar(255) NOT NULL')
	],
	'answer': [
		('script', 'mediumtext NOT NULL'),	# tab-separated list of chapters.
		('question', 'text NOT NULL'),
		('answer', 'longblob NOT NULL'),
		('style', 'mediumtext DEFAULT NULL')
	]
} # }}}

# Main program {{{
server, serverdata = userdata.setup(connection_selector, config, db_config, player_config, httpdirs = ('html',), proxy = config['proxy'])
content.init(serverdata)

print('server is running on port {}'.format(config['port']))
websocketd.fgloop()
# }}}

# vim: set foldmethod=marker :
