#!/usr/bin/python3
# vim: set fileencoding=utf-8 :

# Imports and config. {{{
import sys
import os
import math
import re
try:
	from crypt import crypt
except:
	print('Warning: crypt could not be imported; storing passwords in plain text', file = sys.stderr)
	crypt = lambda pw, salt: pw
import traceback
import time
import random
import fhs
import websocketd
import json
from markdown import markdown
from websocketd import log
fhs.option('data', 'path to user and game data', default = '.')
fhs.option('port', 'network port to listen for players', default = '7000')
fhs.option('admin-port', 'network port to listen for admin', default = '7001')
fhs.option('sandbox-port', 'network port to listen for sandbox', default = '7002')
fhs.option('content', 'url to regular content', default = 'content')
fhs.option('sandbox', 'path to sandbox content, relative to <data path>/html/sandbox/', default = 'sandbox')
fhs.option('lazysave', 'Only save when user logs out (default is on every change)', argtype = bool)
fhs.option('secret', 'If set, key to log in as any user (including admin) without cookie', default = '')
fhs.option('proxy', 'virtual proxy directory', default = 'lesverhaal')
fhs.option('proxy-admin', 'virtual proxy directory for admin', default = 'lesverhaal-admin')
fhs.option('proxy-sandbox', 'virtual proxy directory for sandbox', default = 'lesverhaal-sandbox')
fhs.option('logfile', 'file for logging events', default = '')
fhs.option('loglimit', 'maximum loglevel that is written to screen', default = 1)
fhs.option('python', 'use Python scripts (default is Lua)', argtype = bool)
fhs.option('insecure', 'force the use of insecure Python handling (internal instead of chroot)', argtype = bool)
fhs.option('jail', 'command to run a worker jail (only when --python is used and --insecure is not)', default = 'firejail --quiet --nonewprivs --chroot=chroot --net=none --noprofile /worker')
config = fhs.init(help = 'Visual novel style tool for students to learn with teacher monitoring options', contact = 'Bas Wijnen <wijnen@debian.org>', version = '0.1')
from debug import debug
import content
import user
# }}}

''' Log priorities: {{{
		0: Critical (system code errors)
		1: Important (user code errors)
		2: Normal (communication notifications)
		3: Debug
}}} '''
#'''

tosuper_dict = {'0': '⁰', '1': '¹', '2': '²', '3': '³', '4': '⁴', '5': '⁵', '6': '⁶', '7': '⁷', '8': '⁸', '9': '⁹', '-': '⁻', '+': '⁺', '=': '⁼', '(': '⁽', ')': '⁾', 'n': 'ⁿ'}
def tosuper(src):
	return ''.join(tosuper_dict[c] if c in tosuper_dict else c for c in src)

fromsuper_dict = {v: k for k, v in tosuper_dict.items()}
def fromsuper(src):
	return ''.join(fromsuper_dict[c] if c in fromsuper_dict else c for c in src)

class Admin_Connection: # {{{
	def __init__(self, remote): # {{{
		self.remote = remote
		remote.closed = self._closed
		self.user = None
		try:
			if 'cookie' in self.remote.data['headers']:
				c = self.remote.data['headers']['cookie']
				kv = [chunk.strip().split('=', 1) for chunk in c.split(';')]
				kv = {x[0]: x[1] for x in kv}
				if 'name' in kv and 'key' in kv and (kv['name'], 'admin') in user.users and user.users[(kv['name'], 'admin')]['cookie'] == kv['key']:
					if self._login(kv['name']):
						return
		except IndexError:
			pass
		q = remote.data['query']
		keys = ('name', 'secret')
		if config['secret'] != '' and all(x in q for x in keys) and q['secret'][0] == config['secret']:
			if self._login(q['name'][0]):
				return
		self.refresh = lambda: self.remote.login.event()
		self.remote.login.event()
	# }}}
	def login(self, name, password): # {{{
		u = user.load(name.strip(), 'admin')
		if u is None:
			debug(2, 'Invalid admin {} from {}:{}'.format(name, *self.remote.socket.remote))
			return False
		crypted = crypt(password, salt = u['password'])
		if crypted != u['password']:
			debug(2, 'Invalid password for {} from {}:{}'.format(name, *self.remote.socket.remote))
			return False
		if not self._login(name.strip()):
			debug(2, 'Login failed for other reason')
			self.remote.login.event()
			self.refresh = lambda: self.remote.login.event()
		debug(2, 'login function returns')
		return True
	# }}}
	def _login(self, name): # {{{
		u = user.load(name, 'admin')
		if u is None:
			return False
		if u['connection'] is not None:
			debug(3, 'Replacing connection for ' + name)
			try:
				u['connection'].remote.replaced.event()
			except:
				pass
			u['connection'].remote.close()
		user.users[(u['filename'], 'admin')] = u
		u['connection'] = self
		self.user = u
		if 'cookie' not in user.users[(u['filename'], 'admin')]:
			user.users[(u['filename'], 'admin')]['cookie'] = ''.join(chr(random.randrange(ord('a'), ord('z') + 1)) for _ in range(32))
		self.remote.cookie.event(u['filename'], user.users[(u['filename'], 'admin')]['cookie'])
		debug(1, 'Admin {} logged in from {}:{}'.format(name, *self.remote.socket.remote))
		user.admins[name.lower()] = self
		self.list_groups()
		return True
	# }}}
	def _closed(self): # {{{
		self.remote.close()
		if self.user is None:
			debug(2, 'admin connection to {}:{} lost before logging in'.format(*self.remote.socket.remote))
			return
		debug(1, 'disconnecting admin {}'.format(self.user['name']))
		try:
			user.users.pop((self.user['filename'], 'admin'))
		except:
			pass
		try:
			user.admins.pop(self.user['filename'])
		except:
			pass
	# }}}
	def list_groups(self): # {{{
		'''Show selection of groups to choose.'''
		assert self.user is not None
		self.refresh = lambda: self.list_groups()
		groups = []
		for g in os.listdir(os.path.join(config['data'], 'users')):
			if g == 'admin' or g.lower() != g:
				continue
			groups.append([g])
			chapters = content.list(g)
			keys = list(chapters.keys())
			keys.sort()
			for c in keys:
				for s in chapters[c]:
					groups[-1].append(((c, s), sum(user.users[u]['group'].lower() == g and user.users[u]['section'] == (c, s) for u in user.users)))
		groups.sort()
		self.remote.group_list.event(groups)
	# }}}
	def show_section(self, group, section): # {{{
		'''Show questions for one section.'''
		assert self.user is not None
		section = tuple(section)
		self.refresh = lambda: self.show_section(group, section)
		parts, errors = content.get(group, section)
		questions = []
		def add_block(block):
			for p in block:
				if p['command'] == 'while':
					add_block(p['code'])
				elif p['command'] == 'if':
					for b in p['code']:
						add_block(b[1])
				elif p['command'] == 'video':
					questions.append({'type': 'video', 'name': 'video', 'markdown': p['video'], 'option': None, 'line': p['line']})
				elif p['command'] == 'question':
					questions.append({'type': p['type'], 'name': p['variable'], 'markdown': p['markdown'], 'option': p['option'], 'line': p['line']})
		add_block(parts)
		questions.append({'type': 'end', 'name': '', 'markdown': '', 'option': None, 'line': math.nan})
		students = []
		def make_field(student, question):
			active = False
			if student['section'] == section:
				if len(student['run_stack']) > 0:
					frame = student['run_stack'][-1]
					if len(frame['program']) > frame['current']:
						if frame['program'][frame['current']]['line'] == question['line']:
							active = True
				elif question['type'] == 'end':
					active = True
			return {'active': active, 'attempts': student['answers'][section][question['name']] if question['type'] not in ('video', 'end') and section in student['answers'] and question['name'] in student['answers'][section] else None}
		def make_other_field(student, question):
			return {'active': False, 'attempts': student['answers'][section][question['name']] if question['type'] not in ('video', 'end') and section in student['answers'] and question['name'] in student['answers'][section] else None}
		for s in user.users:
			if user.users[s]['group'].lower() != group.lower():
				continue
			students.append({'password': bool(user.users[s]['password']), 'name': user.users[s]['name'], 'code': s, 'login': user.users[s]['section'] == section, 'connected': user.users[s]['connection'] is not None, 'answers': tuple(make_field(user.users[s], q) for q in questions)})
		students.sort(key = lambda s: (not s['login'], s['name'], s['code']))
		# Add non-connected students to the list.
		others = []
		for u in user.list_group(group):
			if (u, group) in user.users:
				continue
			student = user.load(u, group)
			if student is None:
				debug(0, 'student found but unloadable: {}:{}'.format(u, group))
				continue
			others.append({'password': bool(student['password']), 'name': student['name'], 'code': u, 'login': None, 'connected': False, 'answers': tuple(make_other_field(student, q) for q in questions)})
		try:
			others.sort(key = lambda s: (s['name'], s['code']))
		except:
			pass
		students.extend(others)
		self.remote.students_list.event(group, questions, students)
	# }}}
	def reset_password(self, student, group): # {{{
		assert self.user is not None
		u = user.load(student, group)
		assert u is not None
		u['password'] = None
		user.save(u)
	# }}}
# }}}

#'''

# Class for handling user script commands. {{{
# There are several implementations of te Environment class.
# It needs to define:
# - constructor with no arguments (or no constructor).
# - set(self, key, value):
#	Set a value in the game's namespace.
# - run(self, wake, script, allow_ui = True):
#	Run code in the game's namespace.
#	If allow_ui is True, animation commands are allowed from the script.
#	This function must be a generator.
# - compute(self, wake, expr, as_str):
#	Run code in the game's namespace and return a value.
#	The value is a str if as_str is True, a bool otherwise.
#	This function must be a generator.
# - finish(self):
#	Clean up the game's environment.

class Python_local: # Run code using exec and eval. {{{
	'''This class handles the userspace python environment.
	This runs within this program and is therefore not suitable for untrusted code.
	'''
	def add_to_pending(self, item):
		if self.pending is None:
			raise ValueError('cannot use ui commands in this context')
		self.pending.append(item)
	def __init__(self):
		self.pending = None
		self.variables = {
			'answer': lambda key, value = None: self.add_to_pending(['answer', key, value]),
			}
	def set(self, key, value):
		self.variables[key] = value
	def compute(self, wake, expr, as_str):
		try:
			ret = eval(expr, self.variables)
		except:
			error_text = str(sys.exc_info()[1])
			log('Error in expression %s: %s' % (expr, error_text))
			ret = '[%s]' % error_text if as_str else False
		return str(ret) if as_str else bool(ret)
		# This version of Environment does not support asynchronous operation, but it needs to be a generator.
		yield
	def run(self, wake, script, allow_ui = True):
		if allow_ui:
			self.pending = []
		exec(script, self.variables)
		if allow_ui:
			ret = self.pending
			self.pending = None
			return ret
		return []
		# This version of Environment does not support asynchronous operation, but it needs to be a generator.
		yield
	def finish(self):
		pass
# }}}

class Python_secure: # Run code in a sandbox. {{{
	'''This class handles the userspace python environment.
	This should run a separate process in a firejail chroot without network access.
	That needs to be set up externally. This class just runs a program that should do that.
	'''
	def __init__(self):
		self.worker = subprocess.Popen(shlex.split(config['jail']), stdin = subprocess.PIPE, stdout = subprocess.PIPE, stderr = sys.stderr, close_fds = True, encoding = 'utf-8')
		flag = fcntl.fcntl(self.worker.stdout, fcntl.F_GETFL)
		fcntl.fcntl(self.worker.stdout, fcntl.F_SETFL, flag | os.O_NONBLOCK)
		self.data = ''
	def set(self, key, value):
		v = json.dumps(value)
		self.worker.stdin.write(('set\t%s\t%s\n' % (key, v)))
		self.worker.stdin.flush()
	def read_line(self, wake, cmd):
		self.worker.stdin.write(cmd)
		self.worker.stdin.flush()
		to_handle = None
		def cb():
			self.data += self.worker.stdout.read() 
			if '\n' not in self.data:
				return True
			websocketd.remove_timeout(to_handle)
			pos = self.data.index('\n')
			line = self.data[:pos]
			self.data = self.data[pos + 1:]
			try:
				err, ret = json.loads(line)
			except:
				err = 'Error: failed to parse result from worker'
				ret = None
			if err is not None:
				log(err)
			wake((err, ret))
			return False
		def error():
			log('error on fd from script handler')
			websocketd.remove_read(self.worker.stdout)
			websocketd.remove_timeout(to_handle)
			wake(('Error on fd from script handler', None))
			return False
		def timeout():
			websocketd.remove_read(self.worker.stdout)
			log('Error: timeout on fd from script handler')
			wake(('Error: timeout on fd from script handler', None))
			return False
		websocketd.add_read(self.worker.stdout, cb, error)
		to_handle = websocketd.add_timeout(time.time() + 10, timeout)
		ret = (yield)
		return ret
	def compute(self, wake, expr, as_str):
		err, ret = (yield from self.read_line(wake, '%s\t%s\n' % ('str' if as_str else 'bool', json.dumps(expr))))
		if err is not None:
			return str(err) if as_str else False
		return str(ret) if as_str else bool(ret)
	def run(self, wake, script, allow_pending = True):
		err, ret = (yield from self.read_line(wake, '%s\t%s\n' % ('run' if allow_pending else 'init', json.dumps(script))))
		if err is not None:
			return []
		try:
			return [self.make_cmd(x) for x in ret]
		except:
			log('Error')
			return []
	def finish(self):
		try:
			self.worker.stdin.close()
			self.worker.wait()
		except:
			pass
	def make_cmd(self, x):
		if x[0] == 'answer':
			return ['answer', str(x[1]), None if x[2] is None else str(x[2])]
		else:
			raise ValueError('Unrecognized pending command received from worker')
# }}}

class Lua: # Run Lua code. {{{
	'''This class handles the userspace lua environment.
	It uses the lua library, which is safe for running untrusted code.
	'''
	def __init__(self):
		self.lua = lua.lua()
	def set(self, key, value):
		self.lua.run(var = key, value = value)
	def run(self, wake, script, allow_ui = True):
		self.lua.run(script)
		return
		yield
	def compute(self, wake, expr, as_str):
		ret = self.lua.run('return ' + expr)
		if as_str:
			return str(ret)
		else:
			return bool(ret)
		yield
	def finish(self):
		pass
# }}}

use_lua = not config['python']
insecure = config['insecure'] or not os.path.exists('chroot')
if use_lua:
	import lua
elif insecure:
	log('Warning: using insecure script parsing. Do not run untrusted scripts!')
else:
	import subprocess
	import fcntl
	import shlex

def Environment():
	if use_lua:
		return Lua()
	elif insecure:
		return Python_local()
	else:
		return Python_secure()
# }}}

#'''
class Connection: # {{{
	def __init__(self, remote): # {{{
		debug(2, 'New connection from {}:{}'.format(*remote.socket.remote))
		self.remote = remote
		remote.closed = self._closed
		self.busy = False
		try:
			if 'cookie' in self.remote.data['headers']:
				c = self.remote.data['headers']['cookie']
				kv = [chunk.strip().split('=', 1) for chunk in c.split(';')]
				kv = {x[0]: x[1] for x in kv}
				if 'name' in kv and 'group' in kv and 'key' in kv and (kv['name'], kv['group']) in user.users and user.users[(kv['name'], kv['group'])]['cookie'] == kv['key']:
					if self._login(kv['name'], kv['group']):
						websocketd.add_idle(lambda: websocketd.call(None, self._finish_login))
						return
		except IndexError:
			pass
		q = remote.data['query']
		keys = ('name', 'group', 'secret')
		if config['secret'] != '' and all(x in q for x in keys) and q['secret'][0] == config['secret']:
			if self._login(q['name'][0], q['group'][0]):
				websocketd.add_idle(lambda: websocketd.call(None, self._finish_login))
				return
		self.remote.login.event()
	# }}}
	def login(self, name, group, password): # {{{
		wake = (yield)
		if self.busy:
			return 'duplicate login attempt'
		u = user.load(name.strip(), group.strip())
		if u is None:
			debug(2, 'Invalid user {}:{} on {}:{}'.format(name, group, *self.remote.socket.remote))
			return 'deze naam is onbekend'
		crypted = crypt(password, salt = u['password'])
		if u['password'] is not None and crypted != u['password']:
			debug(2, 'Invalid password for {}:{} on {}:{}'.format(name, group, *self.remote.socket.remote))
			return 'dit wachtwoord is onjuist'
		u = self._login(name.strip(), group.strip())
		# In case the password is new, it needs to be stored.
		if u:
			u['password'] = crypted
			user.save(u)
		self.busy = True
		try:
			yield from self._finish_login(wake)
		finally:
			self.busy = False
		return None
	# }}}
	def _login(self, name, group): # {{{
		u = user.load(name, group.lower())
		if u is None:
			debug(2, 'failed login for {}:{}'.format(name, group))
			return None
		if u['connection'] is not None:
			debug(2, 'Replacing connection for ' + name)
			try:
				u['connection'].remote.replaced.event()
			except:
				pass
			u['connection'].remote.close()
		else:
			user.users[(name.lower(), group.lower())] = u
		u['connection'] = self
		self.user = u
		debug(1, 'User {}:{} logged in from {}:{}'.format(name, group, *self.remote.socket.remote))
		if 'cookie' not in u:
			u['cookie'] = ''.join(chr(random.randrange(ord('a'), ord('z') + 1)) for _ in range(32))
		if 'section' not in u:
			u['program'] = []
			u['run_stack'] = []
			u['section'] = None	# Current section.
			u['question'] = None
		self.remote.cookie.event(u['filename'], group.lower(), u['cookie'])
		self.remote.contents.event(content.list(group))
		self.remote.main.event()
		user.refresh_admins()
		return u
	# }}}
	def _finish_login(self, wake = None): # {{{
		if wake is None:
			wake = (yield)
		if self.user['section'] is not None:
			if len(self.user['run_stack']) > 0 and len(self.user['run_stack'][-1]['program']) > 1:
				setup = []
				state = self.user['_kinetic_state']
				if state['background'] is not None:
					setup.append({'action': 'scene', 'target': state['background'], 'args': {'with': None}})
				for spr in state['sprite']:
					s = state['sprite'][spr]
					setup.append({'action': 'show', 'target': spr, 'image': s['image'], 'args': {'from': s['from'], 'to': s['to'], 'scale': s['scale'], 'rotation': s['rotation'], 'with': None, 'around': None, 'in': None}})
				self.remote.kinetic.event(setup, state['music'])
				if not (yield from self._run_item(wake, self.user['run_stack'][-1]['program'][self.user['run_stack'][-1]['current']])):
					debug(0, 'Bug: saved state of user {}:{} was not a waiting state'.format(name, group))
					yield from self._run(wake)
	# }}}
	def _closed(self): # {{{
		self.remote.close()
		if not hasattr(self, 'user'):
			debug(2, 'connection to {}:{} lost before logging in'.format(*self.remote.socket.remote))
			return
		debug(1, 'disconnecting {}:{}'.format(self.user['name'], self.user['group']))
		user.save(self.user)
		self.user['connection'] = None
		# TODO: schedule a timeout for discarding user data from memory.
		user.refresh_admins()
	# }}}
	def _safe_eval(self, wake, expr, as_str): # {{{
		ret = (yield from self.user['environment'].compute(wake, expr, as_str))
		return str(ret) if as_str else ret
	# }}}
	def _parse_text(self, wake, text): # {{{
		if text is None:
			return None
		if self.user['section'] is not None and self.user['section'][0] == 'sandbox':
			filetarget = config['sandbox'] + '/' + self.user['group'].lower() + '/' + self.user['name'].lower() + '/'
		else:
			filetarget = config['content'] + '/' + self.user['group'].lower() + '/' + self.user['section'][0] + '/' + self.user['section'][1] + '/'
		result = ''
		for m in re.finditer('\${(.*?)}|[^$]+', text):
			if m.group(1) is None:
				result += m.group(0)
			else:
				result += (yield from self._safe_eval(wake, m.group(1), as_str = True))
		return result
	# }}}
	def _parse_time(self, wake, t): # {{{
		i = (yield from self._parse_text(wake, t)).strip()
		r = re.match(r'([-+.e0-9]+)\s*(m?)s$', i)
		if r is None:
			return None
		else:
			try:
				num = float(r.group(1))
				if r.group(2) == 'm':
					num /= 1e3
				return num
			except ValueError:
				debug(0, 'error parsing time {}'.format(i))
				return None
	# }}}
	def _answer(self, wake, key, value = None): # {{{
		'''Set style for last answer.
		With only one argument, the style of the background is set.'''
		if self.user['question'] is None:
			debug(1, 'answer style given before a question was answered')
			return
		if value is None:
			value = key
			key = None
		if key is None:
			key = 'background'
		key = (yield from self._parse_text(wake, key))
		value = (yield from self._parse_text(wake, value))
		self.user['answers'][self.user['section']][self.user['question']][-1]['style'].append((key.strip(), value.strip()))
		user.refresh_admins()
	# }}}
	def _home(self): # {{{
		self.user['section'] = None
		self.user['environment'].finish()
		del self.user['environment']
		user.refresh_admins()
		self.remote.main.event()
	# }}}
	def _clear_pending(self): # {{{
		# update kinetic state.
		def handle_action(action, state):
			if action['action'] in ('speech', 'sound', 'wait'):
				# Nothing to update.
				pass
			elif action['action'] == 'scene':
				state['background'] = action['target']
			elif action['action'] == 'music':
				state['music'] = action['target']
			elif action['action'] in ('serial', 'parallel'):
				for a in action['actions']:
					handle_action(a, state)
			elif action['action'] == 'hide':
				del state['sprite'][action['target']]
			else:
				assert action['action'] in ('show', 'move')
				if action['target'] not in state['sprite']:
					state['sprite'][action['target']] = {'from': [(0, 0), (0, 0), None], 'to': [(0, 0), (0, 0), None], 'scale': None, 'rotation': None, 'image': None}
				target = state['sprite'][action['target']]
				target['image'] = action['image']
				args = action['args']
				for prop in ('from', 'to', 'scale', 'rotation'):
					if args[prop] is not None:
						target[prop] = args[prop]
		for action in self.user['_pending']:
			handle_action(action, self.user['_kinetic_state'])
		#debug(0, repr(self.user['_pending']))
		self.user['_pending'] = []
	# }}}
	def home(self): # {{{
		if self.busy and not force:
			traceback.print_stack()
			log('attempt to home while busy')
			return
		self._home()
	# }}}
	def start(self, section): # {{{
		wake = (yield)
		if self.busy:
			log('attempt to start while busy')
			traceback.print_stack()
			return
		self.user['section'] = tuple(section)
		self.user['_kinetic_state'] = {'background': None, 'sprite': {}, 'music': None}
		self.busy = True
		try:
			yield from self._start(wake, section, content.get(self.user['group'], self.user['section']), False)
		finally:
			self.busy = False
	# }}}
	def _start(self, wake, section, section_content, send_errors): # {{{
		self.user['program'], errors = section_content
		if send_errors:
			if len(errors) > 0:
				errors = markdown('# Errors:\n' + '\n\n'.join(errors))
			else:
				errors = ''
			self.remote.error.event(errors)
		self.user['run_stack'] = [{'program': self.user['program'], 'current': 0}]
		self.user['sprite'] = {}
		self.user['_pending'] = []
		self.user['question'] = None
		def goto(line):
			while len(self.user['run_stack']) > 1:
				self.user['run_stack'].pop()
			self.user['run_stack'][-1]['current'] = line
		self.user['environment'] = Environment()
		self.user['environment'].set('name', self.user['name'])
		self.user['environment'].set('group', self.user['group'])
		self._load_sprite('common/invalid', '')
		startup = fhs.read_data(os.path.join('include', 'startup.' + ('lua' if use_lua else 'py'))
		if startup is not None:
			try:
				yield from self.user['environment'].run(wake, startup.read(), False)
			except:
				debug(1, 'Error in startup script')
				traceback.print_exc()
		yield from self._run(wake)
	# }}}
	def _question(self, wake, qtype, last_answer, markdown, options): # {{{
		if qtype == 'unit':
			qtype = 'short'
		if qtype == 'longunit':
			qtype = 'longshort'
		qtext = (yield from self._parse_text(wake, markdown))
		parsed_options = []
		if options is not None:
			for x in options:
				parsed_options.append((yield from self._parse_text(wake, x)))
		self.remote.question.event(self.user['_pending'], qtext, qtype, parsed_options, last_answer)
		self.breaking = True
		return True
	# }}}
	def _add_character(self, code, name, imgs, ext): # {{{
		self.user['characters'][code] = {'name': name, 'imgs': imgs, 'ext': ext, 'mood': 'default', 'x': 0, 'y': 0}
		c = self.user['characters'][code]
	# }}}
	def _show(self, tag, mood = None, at = 'center', transition = None, timing = None): # {{{
		yield from self._run_item(wake, ['story', None, content.showhide(True, tag, mood, at, transition, timing, False, None)])
	# }}}
	def _hide(self, tag, at = 'center', transition = None, timing = None): # {{{
		yield from self._run_item(wake, ['story', None, content.showhide(False, tag, None, at, transition, timing, False, None)])
	# }}}
	def _run(self, wake): # {{{
		watchdog = 0
		while len(self.user['run_stack']) > 0:
			watchdog += 1
			if watchdog > 1000:
				debug(1, 'hanging script detected: {}; killing it'.format(self.user['section']))
				self.remote.error.event(['Script stopped working and was killed.'])
				self.user['run_stack'] = [{'program': self.user['program'], 'current': len(self.user['program'])}]
				user.refresh_admins()
				return
			# Pop off stack levels until there's an instruction.
			while len(self.user['run_stack'][-1]['program']) <= self.user['run_stack'][-1]['current']:
				self.user['run_stack'].pop()
				if len(self.user['run_stack']) == 0:
					# Send final "question".
					self.remote.question.event(self.user['_pending'], '', 'choice', ['Done'])
					self.breaking = True
					user.refresh_admins()
					return
			# Run instructions.
			if (yield from self._run_item(wake, self.user['run_stack'][-1]['program'][self.user['run_stack'][-1]['current']])):
				break
		user.refresh_admins()
	# }}}
	def _run_item(self, wake, code): # {{{
		debug(3, '{}:{} running item {}'.format(self.user['name'], self.user['group'], repr(code)))
		if code['command'] == 'label':
			pass
		elif code['command'] == 'answer':
			yield from self._answer(wake, 'background', code['answer'])
		elif code['command'] == 'if':
			self.user['run_stack'][-1]['current'] += 1
			for expr, target in code['code']:
				if expr is None or (yield from self._safe_eval(wake, expr, as_str = False)):
					self.user['run_stack'].append({'program': target, 'current': 0})
					break
			return False
		elif code['command'] == 'while':
			# Don't increment instruction pointer, so the loop restarts.
			if (yield from self._safe_eval(wake, code['test'], as_str = False)):
				self.user['run_stack'].append({'program': code['code'], 'current': 0})
			else:
				# exit the while loop.
				self.user['run_stack'][-1]['current'] += 1
				# handle else clause, if present.
				if code['else'] is not None:
					self.user['run_stack'].append({'program': code['else'], 'current': 0})
			return False
		elif code['command'] in ('continue', 'break'):
			while self.user['run_stack'][-1]['current'] >= len(self.user['run_stack'][-1]['program']) or self.user['run_stack'][-1]['program'][self.user['run_stack'][-1]['current']]['command'] != 'while':
				self.user['run_stack'].pop()
			if code['command'] == 'break':
				self.user['run_stack'][-1]['current'] += 1
			return False
		elif code['command'] == 'goto':
			# Break to top level and jump to requested label.
			while len(self.user['run_stack']) > 1:
				self.user['run_stack'].pop()
			self.user['run_stack'][-1]['current'] = code['target']
			return False
		elif code['command'] == 'code':
			self.breaking = False
			self.user['run_stack'][-1]['current'] += 1	# Do this before running the code, so goto works.
			try:
				new_commands = (yield from self.user['environment'].run(wake, code['code']))
				if len(new_commands) > 0:
					self.user['run_stack'].append({'program': new_commands, 'current': 0})
			except:
				debug(0, 'Error in script: {}'.format(code['code']))
				traceback.print_exc()
				self.remote.error.event(code['code'])
			return self.breaking
		elif code['command'] == 'video':
			url = config['content'] + '/' + self.user['group'].lower() + '/' + self.user['section'][0] + '/' + self.user['section'][1] + '/' + code['video']
			self.remote.video.event(self.user['_pending'], url)
			return True
		elif code['command'] == 'sprite':
			self._load_sprite(code['sprite'], code['tag'])
		elif code['command'] == 'kinetic':
			def build_kinetic(wake, item):
				if item['action'] == 'speech':
					target = item['speaker']
					speaker = None if target is None else self.user['sprite'][target]['name'] if target in self.user['sprite'] else '(' + target + ')'
					if target in self.user['sprite']:
						if item['image'] not in self.user['sprite'][target]['style']:
							if item['image'] is not None:
								debug(0, 'ignoring invalid image %s for %s' % (item['image'], target))
								mood = self.user['sprite'][target]['mood']
							else:
								mood = item['image']
						else:
							mood = None
						style = self._get_sprite_style(target, mood)
					else:
						style = {'url': None, 'size': None, 'hotspot': (.5, 0)}
					return {'action': 'speech', 'speaker': speaker, 'target': target, 'image': style, 'text': markdown((yield from self._parse_text(wake, item['markdown'])))}
				if item['action'] == 'wait':
					return {'action': 'wait', 'time': (yield from self._parse_time(wake, item['time']))}
				if item['action'] in ('sound', 'music'):
					target = None if item['target'] is None else (yield from self._parse_text(wake, item['target']))
					return {'action': item['action'], 'target': target}
				if item['action'] in ('serial', 'parallel'):
					actions = []
					for x in item['actions']:
						actions.append((yield from build_kinetic(wake, x)))
					return {'action': item['action'], 'args': item['args'], 'actions': actions}
				args = {}
				if item['args']['with'] is None:
					args['with'] = None
				else:
					w = (yield from self._parse_text(wake, item['args']['with']))
					if w not in ('jump', 'dissolve', 'move'):
						debug(0, 'invalid transition {}'.format(w))
						args['with'] = None
					else:
						args['with'] = w
				if item['args']['in'] is None:
					args['in'] = None
				else:
					args['in'] = (yield from self._parse_time(wake, item['args']['in']))
				def parse_location(wake, loc):
					if loc is None:
						return None
					l = [x.strip() for x in (yield from self._parse_text(wake, loc)).split()]
					if l[0] == 'outleft':
						l[0] = (1, -1)
					elif l[0] == 'inleft':
						l[0] = (-1, -1)
					elif l[0] == 'outright':
						l[0] = (-1, 1)
					elif l[0] == 'inright':
						l[0] = (1, 1)
					elif l[0] == 'left':
						l[0] = (0, -.4)
					elif l[0] == 'center':
						l[0] = (0, 0)
					elif l[0] == 'right':
						l[0] = (0, .4)
					else:
						try:
							l[0] = (0, float(l[0]))
						except:
							l[0] = (0, 0)
					if len(l) == 1:
						l.append((0, 0))
					elif l[1] == 'outbottom':
						l[1] = (1, 0)
					elif l[1] == 'inbottom':
						l[1] = (-1, 0)
					elif l[1] == 'outtop':
						l[1] = (-1, 1)
					elif l[1] == 'intop':
						l[1] = (1, 1)
					elif l[1] == 'bottom':
						l[1] = (0, 0)
					elif l[1] == 'low':
						l[1] = (0, .2)
					elif l[1] == 'middle':
						l[1] = (0, .5)
					elif l[1] == 'high':
						l[1] = (0, .8)
					elif l[1] == 'top':
						l[1] = (0, 1)
					else:
						try:
							l[1] = (0, float(l[1]))
						except:
							l[1] = (0, 0)
					if len(l) == 2:
						l.append(None)
					else:
						try:
							l[2] = int(l[2])
						except:
							l[2] = None
					return l
				def parse_around(wake, loc):
					if loc is None:
						return None
					l = [x.strip() for x in (yield from self._parse_text(wake, loc)).split()]
					if l[-1] in ('cw', 'ccw'):
						cw = l[-1] == 'cw'
						l.pop()
					else:
						cw = False
					if l[0] == 'left':
						l[0] = -.4
					elif l[0] == 'center':
						l[0] = 0
					elif l[0] == 'right':
						l[0] = .4
					else:
						try:
							l[0] = float(l[0])
						except:
							l[0] = 0
					if len(l) == 1:
						l.append(0)
					elif l[1] == 'bottom':
						l[1] = 0
					elif l[1] == 'low':
						l[1] = .2
					elif l[1] == 'middle':
						l[1] = .5
					elif l[1] == 'high':
						l[1] = .8
					elif l[1] == 'top':
						l[1] = 1
					else:
						try:
							l[1] = float(l[1])
						except:
							l[1] = 0
					return l[:2] + [cw]
				args['to'] = (yield from parse_location(wake, item['args']['to']))
				args['from'] = (yield from parse_location(wake, item['args']['from']))
				args['around'] = (yield from parse_around(wake, item['args']['around']))
				if item['args']['scale'] is None:
					args['scale'] = None
				else:
					s = [x.strip() for x in (yield from self._parse_text(wake, item['args']['scale'])).split()]
					try:
						s = [float(x) for x in s]
						if len(s) == 1:
							s.append(s[0])
						elif len(s) > 2:
							s = [s[0], s[1]]
					except:
						debug(0, 'error parsing scale {}'.format(s))
						s = None
					args['scale'] = r
				if item['args']['rotation'] is None:
					args['rotation'] = None
				else:
					r = (yield from self._parse_text(wake, item['args']['rotation'])).strip()
					if r.endswith('°'):
						f = 360
						r = r[:-1]
					else:
						f = 1
					try:
						r = float(r) / f
					except:
						debug(0, 'error parsing rotation {}'.format(r))
						r = None
					args['rotation'] = r
				if item['target'] is None:
					target = None
					image = None
				else:
					target = (yield from self._parse_text(wake, item['target']))
					if item['action'] != 'scene':
						mood = (yield from self._parse_text(wake, item['mood']))
						style = self._get_sprite_style(target, mood)
					else:
						style = {'url': None, 'size': None, 'hotspot': (.5, 0)}
				return {'action': item['action'], 'target': target, 'image': style, 'args': args}
			actions = []
			for x in code['kinetic']:
				actions.append((yield from build_kinetic(wake, x)))
			self.user['_pending'].extend(actions)
		elif code['command'] == 'question':
			if code['type'] == 'hidden':
				self._store_answer(code['variable'], (yield from self._safe_eval(wake, code['markdown'], as_str = True)))
			else:
				# Question.
				if self.user['section'] in self.user['answers'] and code['variable'] in self.user['answers'][self.user['section']]:
					last_answer = self.user['answers'][self.user['section']][code['variable']][-1]['raw']
				else:
					last_answer = None
				return (yield from self._question(wake, code['type'], last_answer, code['markdown'], code['option']))
		else:
			debug(0, 'invalid command {}'.format(code))
		self.user['run_stack'][-1]['current'] += 1
		return False
	# }}}
	def _get_filename(self, name, type): # {{{
		'''Get a filename for a local (non-web) file. Returns the filename and if it is in common/.'''
		parts = name.split('/')
		if parts[0] == 'common':
			return os.path.join('common', type, *parts[1:]), True
		else:
			return os.path.join('users', self.user['group'], 'Content', self.user['section'][0], type, *parts), False
	# }}}
	def _load_sprite(self, loadname, tag): # {{{
		filename, is_common = self._get_filename(loadname, 'sprite')
		data = content.load822(filename)
		ret = {'base': os.path.dirname(filename), 'tag': tag, 'style': {}, 'mood': None, 'common': is_common}
		if 'name' in data:
			# If name is a multi-line value, make that work in markdown notation.
			ret['name'] = '\n\n'.join(data.pop('name'))
		else:
			ret['name'] = tag.capitalize()
		if 'image' in data:
			for f in data['image']:
				r = re.match('^\s*(\S+)(?:\s+(\d+)\s+(\d+)(?:\s+(\d+)\s+(\d+))?)?\s*$', f)
				if r is None:
					debug(0, 'invalid image line in %s: %s' % (loadname, f))
					continue
				base = r.group(1).strip().split('/')[-1]	# Base name (everything except directory)
				imgtag = base.rsplit('.', 1)[0]	# base name without extension.
				if r.group(3) is not None:
					hotspot = float(r.group(2)), float(r.group(3))
				else:
					hotspot = .5, 0
				if r.group(5) is not None:
					size = float(r.group(4)), float(r.group(5))
				else:
					size = None
				ret['style'][imgtag] = {'image': r.group(1), 'size': size, 'hotspot': hotspot}
				if ret['mood'] is None:
					ret['mood'] = imgtag
			data.pop('image')
		assert len(data) == 0
		self.user['sprite'][tag] = ret
		return ret
	# }}}
	def _get_sprite_style(self, tag, style): # {{{
		if tag is None:
			return None
		if tag not in self.user['sprite']:
			debug(0, 'getting style %s for unknown sprite %s.' % (style, tag))
			tag = ''
			style = 'default'
		sprite = self.user['sprite'][tag]
		if style not in sprite['style']:
			if style is not None:
				debug(0, 'getting unknown style %s for sprite %s.' % (style, tag))
			style = sprite['mood']
			if style not in sprite['style']:
				debug(0, 'current mood %s is not a valid style for sprite %s.' % (style, tag))
				tag = ''
				style = 'default'
		if sprite['common']:
			r = sprite['style'][style]
			return {'url': 'content/common/' + tag + '/' + r['image'], 'size': r['size'], 'hotspot': r['hotspot']}
		else:
			return {'url': 'content/' + self.user['group'] + '/' + self.user['section'][0] + '/sprite/' + tag + '/' + r['image'], 'size': r['size'], 'hotspot': r['hotspot']}
	# }}}
	def _update_sprite(self, tag, data): # {{{
		for item in ('x', 'y', 'mood'):
			if item in data:
				self.user['characters'][tag][item] = data[item]
		c = self.user['characters'][tag]
		data['url'] = c['imgs'] + (data.pop('mood') if 'mood' in data else 'default') + c['ext']
	# }}}
	def _store_answer(self, question, answer, store = True): # {{{
		self.user['environment'].set(question, answer)
		if store:
			if self.user['section'] not in self.user['answers']:
				self.user['answers'][self.user['section']] = {}
			if question not in self.user['answers'][self.user['section']]:
				self.user['answers'][self.user['section']][question] = []
			if len(self.user['answers'][self.user['section']][question]) == 0 or answer != self.user['answers'][self.user['section']][question][-1]:
				self.user['answers'][self.user['section']][question].append(answer)
			self.user['question'] = question
			if not config['lazysave']:
				user.save(self.user)
		else:
			self.user['question'] = None
	# }}}
	def answer(self, answer): # {{{
		wake = (yield)
		if self.busy:
			log('attempt to answer while busy')
			return
		self._clear_pending()
		debug(3, '{}:{} answers {}'.format(self.user['name'], self.user['group'], answer))
		if len(self.user['run_stack']) == 0:
			# Ignore answer for final "Done" button.
			self._home()
			return
		if self.user['run_stack'][-1]['current'] >= len(self.user['run_stack'][-1]['program']):
			self.busy = True
			try:
				yield from self._run(wake)
			finally:
				self.busy = False
			return
		current = self.user['run_stack'][-1]['program'][self.user['run_stack'][-1]['current']]
		if current['type'] not in ('short', 'long', 'choice', 'unit', 'longshort', 'longunit', 'longchoice'):
			debug(1, 'answer given by {}:{} for non-question: {}'.format(self.remote.socket.remote[0], self.remote.socket.remote[1], current))
			return
		store = not current['variable'].startswith('_')
		def parse_unit(src):
			r = re.match(r'\s*(?:(\S+)\s*=\s*)?([+-]?[0-9]*(?:[.,]\d*)?)(?:·10([⁻⁺]?[⁰¹²³⁴⁵⁶⁷⁸⁹]+))?\s*(\S*)\s*$', src)
			# groups:
			# 1: quantity	(\S+)
			# 2: base value	([+-]?[0-9]*(?:[.,]\d*)?)
			# 3: exponent	(·10([⁻⁺]?[⁰¹²³⁴⁵⁶⁷⁸⁹]+))?
			# 4: unit	(\S*)
			if not r:
				debug(3, 'no match for unit answer')
				answer = {'quantity': None, 'unit': None, 'digits': None, 'value': None}
			try:
				answer = {}
				answer['quantity'] = r.group(1)
				base = r.group(2).replace(',', '.')
				exponent = None if r.group(3) is None else int(fromsuper(r.group(3)))
				answer['unit'] = r.group(4)
				answer['digits'] = len(base.replace('.', '').lstrip('0'))
				answer['value'] = float(base) * (1 if exponent is None else 10 ** exponent)
			except:
				traceback.print_exc()
				answer = {'quantity': None, 'unit': None, 'digits': None, 'value': None}
			debug(3, 'unit-split answer: {}'.format(answer))
			return answer
		raw = answer
		if current['type'] == 'choice':
			if isinstance(answer, int) and 0 <= answer < len(current['option']):
				answer = {'index': answer, 'text': current['option'][answer]}
			else:
				answer = {}
			if len(current['option']) <= 1:
				store = False
		elif current['type'] == 'longchoice':
			if isinstance(answer[0], int) and 0 <= answer[0] < len(current['option']):
				answer = {'index': answer[0], 'text': current['option'][answer[0]], 'long': str(answer[1]).strip()}
			else:
				# Leave answer string as is (but force str); this only happens when users are messing with the js.
				debug(2, 'unparsable longchoice answer: {}'.format(answer))
				answer = {'choice': None, 'long': str(answer).strip()}
		elif current['type'] == 'unit':
			answer = parse_unit(answer)
		elif current['type'] == 'longunit':
			l = answer[1]
			try:
				answer = parse_unit(answer[0])
				answer['long'] = l
			except:
				# Leave answer string as is (but force str); this only happens when users are messing with the js.
				debug(2, 'unparsable longunit answer: {}'.format(answer))
				answer = {}
		elif current['type'].startswith('long') and current['type'] != 'long':
			try:
				answer = {'text': str(answer[0]).strip(), 'long': str(answer[1]).strip()}
			except:
				# Leave answer string as is (but force str); this only happens when users are messing with the js.
				debug(2, 'unparsable long* answer: {}'.format(answer))
				answer = {}
		else:
			answer = {'text': answer}
		answer['raw'] = raw
		answer['style'] = []
		self._store_answer(current['variable'], answer, store)
		self.user['run_stack'][-1]['current'] += 1
		self.busy = True
		try:
			yield from self._run(wake)
		finally:
			self.busy = False
	# }}}
	def video_done(self): # {{{
		wake = (yield)
		if self.busy:
			log('attempt to finish video while busy')
			return
		self._clear_pending()
		if self.user['run_stack'][-1]['current'] >= len(self.user['run_stack'][-1]['program']):
			self.busy = True
			try:
				yield from self._run(wake)
			finally:
				self.busy = False
			return
		current = self.user['run_stack'][-1]['program'][self.user['run_stack'][-1]['current']]
		if current[0] == 'video':
			self.user['run_stack'][-1]['current'] += 1
			self.busy = True
			try:
				yield from self._run(wake)
			finally:
				self.busy = False
	# }}}
	def sandbox_list(self): # {{{
		if self.busy:
			log('attempt to list sandbox while busy')
			return
		if not self.user['sandbox']:
			debug(1, 'User {}:{} is not allowed to use sandbox'.format(self.user['name'], self.user['group']))
			raise PermissionError('User is not allowed to use sandbox')
		basedir = os.path.join(config['data'], 'html', 'sandbox', config['sandbox'], self.user['group'].lower(), self.user['name'].lower())
		if not os.path.exists(basedir):
			return []
		def make_list(base, current):
			ret = []
			for f in os.listdir(os.path.join(base, current)):
				filename = os.path.join(base, current, f)
				if os.path.isdir(filename):
					if f[0] == '.':
						continue
					ret.extend(make_list(base, os.path.join(current, f)))
				else:
					ret.append(os.path.join(current, f))
			return ret
		return make_list(basedir, '')
	# }}}
	def sandbox_remove(self, name): # {{{
		if self.busy:
			log('attempt to remove sandbox while busy')
			return
		if not self.user['sandbox']:
			debug(1, 'User is not allowed to use sandbox')
			raise PermissionError('User is not allowed to use sandbox')
		basedir = os.path.join(config['data'], 'html', 'sandbox', config['sandbox'], self.user['group'].lower(), self.user['name'].lower())
		d = os.path.dirname(name)
		assert '.' not in d and os.path.exists(os.path.join(basedir, name))
		os.unlink(os.path.join(basedir, name))
	# }}}
	def sandbox_play(self, scriptname): # {{{
		wake = (yield)
		if self.busy:
			log('attempt to play sandbox while busy')
			return
		if not self.user['sandbox']:
			debug(1, 'User is not allowed to use sandbox')
			raise PermissionError('User is not allowed to use sandbox')
		basedir = os.path.join(config['data'], 'html', 'sandbox', config['sandbox'], self.user['group'].lower(), self.user['name'].lower())
		d = os.path.dirname(scriptname)
		assert '.' not in d and os.path.exists(os.path.join(basedir, scriptname))
		self.user['section'] = ('sandbox', self.user['name'].lower())
		self.busy = True
		try:
			yield from self._start(wake, self.user['section'], content.get_file(self.user['group'], self.user['section'], os.path.join(basedir, scriptname)), True)
		finally:
			self.busy = False
	# }}}
	def sandbox_get(self, name): # {{{
		if self.busy:
			log('attempt to get sandbox while busy')
			return
		if not self.user['sandbox']:
			debug(1, 'User is not allowed to use sandbox')
			raise PermissionError('User is not allowed to use sandbox')
		basedir = os.path.join(config['data'], 'html', 'sandbox', config['sandbox'], self.user['group'].lower(), self.user['name'].lower())
		d = os.path.dirname(name)
		assert '.' not in d and os.path.exists(os.path.join(basedir, name))
		return open(os.path.join(basedir, name)).read()
	# }}}
	def sandbox_put(self, name, contents): # {{{
		if self.busy:
			log('attempt to put sandbox while busy')
			return
		if not self.user['sandbox']:
			debug(1, 'User is not allowed to use sandbox')
			raise PermissionError('User is not allowed to use sandbox')
		basedir = os.path.join(config['data'], 'html', 'sandbox', config['sandbox'], self.user['group'].lower(), self.user['name'].lower())
		d = os.path.dirname(name)
		assert '.' not in d
		os.makedirs(basedir, exist_ok = True)
		open(os.path.join(basedir, name), 'w').write(contents)
	# }}}

def sandbox_post(connection): # {{{
	'''Upload a new file for the sandbox.
	Credentials must be provided in the cookie. User must be allowed to use the sandbox.
	'''
	if connection.busy:
		log('attempt to post sandbox while busy')
		return
	if 'cookie' not in connection.headers or 'file' not in connection.post[1]:
		debug(1, 'ignoring invalid POST request')
		sandboxserver.reply(connection, 404, 'invalid POST request', 'text/plain;charset=utf-8')
		return False
	c = connection.headers['cookie']
	kv = [chunk.strip().split('=', 1) for chunk in c.split(';')]
	kv = {x[0]: x[1] for x in kv}
	if 'name' not in kv or 'group' not in kv or 'key' not in kv or (kv['name'], kv['group']) not in user.users or user.users[(kv['name'], kv['group'])]['cookie'] != kv['key']:
		debug(1, 'invalid cookie for POST')
		sandboxserver.reply(connection, 403, b'invalid cookie for POST request', 'text/plain;charset=utf-8')
		return False
	u = user.users[(kv['name'], kv['group'])]
	if not u['sandbox']:
		debug(1, 'User is not allowed to use sandbox')
		sandboxserver.reply(connection, 403, b'User is not allowed to use sandbox', 'text/plain;charset=utf-8')
		return False
	# Credentials are good, save the files.
	basedir = os.path.join(config['data'], 'html', 'sandbox', config['sandbox'], kv['group'].lower(), kv['name'].lower())
	for f in connection.post[1]['file']:
		basename = os.path.basename(f[1]).split('.')
		if len(basename) > 1:
			basename[-2:] = [basename[-2] + '.' + basename[-1]]
		filename = os.path.join(basedir, *basename)
		os.makedirs(os.path.join(basedir, *basename[:-1]), exist_ok = True)
		# Copy the file.
		try:
			with open(filename, 'wb') as w:
				with open(f[0], 'rb') as r:
					w.write(r.read())
			debug(1, 'copied {} to {}'.format(f[0], filename))
		except:
			debug(1, 'unable to copy file')
			traceback.print_exc()
	sandboxserver.page(connection)
	return False
# }}}
# }}}

# Main program {{{
server = websocketd.RPChttpd(config['port'], Connection, httpdirs = [os.path.join('html', 'main')], tls = False, proxy = config['proxy'])
adminserver = websocketd.RPChttpd(config['admin-port'], Admin_Connection, httpdirs = [os.path.join('html', 'admin')], proxy = config['proxy-admin'], tls = False)
sandboxserver = websocketd.RPChttpd(config['sandbox-port'], Connection, httpdirs = [os.path.join('html', 'sandbox')], tls = False, proxy = config['proxy-sandbox'] or ())
sandboxserver.post = sandbox_post
print('servers are running on ports {}, {} and {}'.format(config['port'], config['admin-port'], config['sandbox-port']))
websocketd.fgloop()
# }}}

# vim: set foldmethod=marker :
