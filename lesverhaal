#!/usr/bin/python3
# vim: set fileencoding=utf-8 :

# Imports and config. {{{
import sys
import os
import base64
import io
import math
import re
import zipfile
import traceback
import time
import random
import fhs
import websocketd
import json
import userdata
import content
from markdown import markdown
from websocketd import log

fhs.option('port', 'network port to listen for players', default = '7000')
fhs.option('proxy', 'virtual proxy directory', default = 'lesverhaal')
fhs.option('logfile', 'file for logging events', default = '')
fhs.option('loglimit', 'maximum loglevel that is written to screen', default = 1)
config = userdata.fhs_init('http://localhost:8879', 'lesverhaal', help = 'Visual novel style tool for students to learn with teacher monitoring options', contact = 'Bas Wijnen <wijnen@debian.org>', version = '0.2')
from debug import debug
# }}}

''' Log priorities: {{{
		0: Critical (system code errors)
		1: Important (user code errors)
		2: Normal (communication notifications)
		3: Debug
}}} '''

# Sub-/superscript helpers. {{{
tosuper_dict = {'0': '⁰', '1': '¹', '2': '²', '3': '³', '4': '⁴', '5': '⁵', '6': '⁶', '7': '⁷', '8': '⁸', '9': '⁹', '-': '⁻', '+': '⁺', '=': '⁼', '(': '⁽', ')': '⁾', 'n': 'ⁿ'}
def tosuper(src):
	return ''.join(tosuper_dict.get(c, c) for c in src)

fromsuper_dict = {v: k for k, v in tosuper_dict.items()}
def fromsuper(src):
	return ''.join(fromsuper_dict.get(c, c) for c in src)
# }}}

# List of all currently logged in users.
users = {}
admins = {}

def refresh_admins(wake): # {{{
	for a in admins:
		yield from admins[a].refresh(wake)
# }}}

# Class for handling user script commands. {{{
# There can be multiple implementations of te Environment class.
# Only Lua is defined. This is not expected to change.
# It needs to define:
# - constructor with no arguments (or no constructor).
# - set(self, key, value):
#	Set a value in the game's namespace.
# - run(self, wake, script, allow_ui = True):
#	Run code in the game's namespace.
#	If allow_ui is True, animation commands are allowed from the script.
#	This function must be a generator.
# - compute(self, wake, expr, as_str):
#	Run code in the game's namespace and return a value.
#	The value is a str if as_str is True, a bool otherwise.
#	This function must be a generator.
# - module(self, name, value):
#	Load the value dict into the environment as the name name.

class Lua: # Run Lua code. {{{
	'''This class handles the userspace lua environment.
	It uses the lua library, which is safe for running untrusted code.
	'''
	def __init__(self):
		self.lua = lua.Lua()
	def set(self, key, value):
		self.lua.run(var = key, value = value)
	def run(self, script, allow_ui = True):
		self.lua.run(script)
	def compute(self, expr, as_str):
		#print('computing: ', expr)
		ret = self.lua.run('return ' + expr)
		if as_str:
			return str(ret)
		else:
			return bool(ret)
	def module(self, name, value):
		self.lua.module(name, value)
# }}}

import lua

def Environment():
	return Lua()
# }}}

class Admin_Connection: # {{{ Class for handling admin connections.
	def __init__(self, my_id, my_name, my_userdata, my_remote, managed_name): # {{{
		self.id = my_id
		self.name = my_name
		self.userdata = my_userdata
		self.remote = my_remote
		self.remote._websocket_closed = self._closed
		admins[my_id] = self
		debug(1, 'admin {} connected'.format(self.name))
	# }}}
	def _init(self, wake): # {{{
		self.script = None
		self.refresh = lambda wake: self.remote.scripts.event((yield from content.list(wake, None)))
		yield from self.refresh(wake)
	# }}}
	def _closed(self): # {{{
		del admins[self.id]
		self.remote._websocket_close()
		debug(1, 'disconnecting admin {}'.format(self.name))
	# }}}
	def _send_script(self, wake): # {{{
		log('sending script')
		questions = (yield from content.list_questions(wake, self.script))
		players = (yield from content.list_players(wake, self.script))
		log('sending qp', questions, players)
		self.remote.script.event(questions, players)
	# }}}
	def select_script(self, script): # {{{
		wake = (yield)
		if script is None:
			yield from self._init(wake)
		else:
			self.script = (yield from content.get_scriptid(wake, script))
			self.refresh = self._send_script
			yield from self.refresh(wake)
	# }}}
# }}}

class Content_Connection: # {{{ Class for handling content management.
	def __init__(self, my_id, my_name, my_userdata, my_remote, managed_name): # {{{
		self.id = my_id
		self.name = my_name
		self.userdata = my_userdata
		self.remote = my_remote
		self.managed_name = managed_name
	def _init(self, wake):
		# TODO: Check that this user is allowed to edit content.
		# Other than that, nothing to do here.
		pass
	# }}}
	# Groups {{{
	def list_groups(self):
		wake = (yield)
		data = (yield from serverdata.select('group', ('id', 'name'), wake = wake))
		return {d[0]: {'name': d[1]} for d in data}
	def add_group(self, name):
		wake = (yield)
		return (yield from serverdata.insert('group', {'name': name}, wake = wake))
	def update_group(self, groupid, name):
		wake = (yield)
		yield from serverdata.update('group', {'name': name}, ('=', 'id', groupid), wake = wake)
	def remove_group(self, groupid):
		wake = (yield)
		yield from serverdata.delete('group', ('=', 'id', groupid), wake = wake)
	# }}}
	# Chapters {{{
	def _list_chapters(self, wake):
		data = (yield from serverdata.select('chapter', ('id', 'name'), wake = wake))
		return {d[0]: {'name': d[1]} for d in data}
	def list_chapters(self):
		wake = (yield)
		return (yield from self._list_chapters(wake))
	def _add_chapter(self, wake, name, parent):
		return (yield from serverdata.insert('chapter', {'name': name, 'parent': parent if parent else None}, wake = wake))
	def add_chapter(self, name, parent):
		wake = (yield)
		return (yield from self._add_chapter(wake, name, parent))
	def update_chapter(self, chapterid, name, parent):
		wake = (yield)
		yield from serverdata.update('chapter', {'name': name, 'parent': parent if parent else None}, ('=', 'id', chapterid), wake = wake)
	def remove_chapter(self, chapterid):
		wake = (yield)
		yield from serverdata.delete('chapter', ('=', 'id', chapterid), wake = wake)
	# }}}
	# Access {{{
	def list_access(self):
		wake = (yield)
		return (yield from serverdata.select('access', ('groupid', 'chapter'), wake = wake))
	def add_access(self, groupid, chapterid):
		wake = (yield)
		present = (yield from serverdata.select('access', ('groupid',), ('and', ('=', 'groupid', groupid), ('=', 'chapter', chapterid)), wake = wake))
		assert len(present) == 0
		yield from serverdata.insert('access', {'groupid': groupid, 'chapter': chapterid}, wake = wake)
	def remove_access(self, groupid, chapterid):
		wake = (yield)
		yield from serverdata.delete('access', ('and', ('=', 'groupid', groupid), ('=', 'chapter', chapterid)), wake = wake)
	# }}}
	# Scripts {{{
	def _list_scripts(self, wake):
		data = (yield from serverdata.select('script', ('id', 'name', 'chapter'), wake = wake))
		return {d[0]: {'name': d[1], 'chapter': d[2]} for d in data}
	def list_scripts(self):
		wake = (yield)
		return (yield from self._list_scripts(wake))
	def _get_script(self, wake, scriptid):
		data = (yield from serverdata.select('script', ('script',), ('=', 'id', scriptid), wake = wake))
		return None if len(data) == 0 else data[0][0]
	def get_script(self, scriptid):
		wake = (yield)
		return (yield from self._get_script(wake, scriptid))
	def _add_script(self, wake, name, chapter, script):
		return (yield from serverdata.insert('script', {'name': name, 'chapter': chapter, 'script': script}, wake = wake))
	def add_script(self, name, chapter, script):
		wake = (yield)
		new_scriptid = (yield from self._add_script(wake, name, chapter, script))
		return (yield from self._update_questions(wake, new_scriptid, script))
	def update_script(self, scriptid, name, chapter, script):
		wake = (yield)
		if script is None:
			yield from serverdata.update('script', {'name': name, 'chapter': chapter}, ('=', 'id', scriptid), wake = wake)
			return []
		else:
			yield from serverdata.update('script', {'name': name, 'chapter': chapter, 'script': script}, ('=', 'id', scriptid), wake = wake)
			return (yield from self._update_questions(wake, scriptid, script))
	def remove_script(self, scriptid):
		wake = (yield)
		yield from serverdata.delete('script', ('=', 'id', scriptid), wake = wake)
		yield from serverdata.delete('question', ('=', 'script', scriptid), wake = wake)
	# }}}
	# Questions {{{
	def _update_questions(self, wake, scriptid, script):
		parsed, errors, questions, labels = content.parse_script(script)
		#print('questions', questions)
		yield from serverdata.delete('question', ('=', 'script', scriptid), wake = wake)
		for q in questions:
			yield from serverdata.insert('question', {'id': q['id'], 'script': scriptid, 'type': q['type'], 'description': q['description']}, wake = wake)
		return errors
	def list_questions(self):
		wake = (yield)
		data = (yield from serverdata.select('question', ('id', 'script', 'type', 'description'), wake = wake))
		return {('%d:%s' % (d[1], d[0])): {'type': d[2], 'description': d[3]} for d in data}
	# }}}
	# Sprites {{{
	def _list_sprites(self, wake):
		data = (yield from serverdata.select('sprite', ('name', 'chapter', 'id'), wake = wake))
		return {d[2]: {'name': d[0], 'chapter': d[1]} for d in data}
	def list_sprites(self):
		wake = (yield)
		return (yield from self._list_sprites(wake))
	def _add_sprite(self, wake, name, chapter):
		return (yield from serverdata.insert('sprite', {'name': name, 'chapter': chapter}, wake = wake))
	def add_sprite(self, name, chapter):
		wake = (yield)
		return (yield from self._add_sprite(wake, name, chapter))
	def update_sprite(self, spriteid, name, chapter):
		wake = (yield)
		yield from serverdata.update('sprite', {'name': name, 'chapter': chapter}, ('=', 'id', spriteid), wake = wake)
	def remove_sprite(self, spriteid):
		wake = (yield)
		yield from serverdata.delete('sprite', ('=', 'id', spriteid), wake = wake)
	# }}}
	# Images {{{
	def _list_images(self, wake):
		data = (yield from serverdata.select('image', ('id', 'sprite', 'mood', 'width', 'height', 'hotx', 'hoty'), wake = wake))
		return {d[0]: {'sprite': d[1], 'mood': d[2], 'size': (d[3], d[4]), 'hotspot': (d[5], d[6])} for d in data}
	def list_images(self):
		wake = (yield)
		return (yield from self._list_images(wake))
	def _get_image(self, wake, imageid):
		data = (yield from serverdata.select('image', ('url', 'sprite', 'mood', 'width', 'height', 'hotx', 'hoty'), ('=', 'id', imageid), wake = wake))
		return None if len(data) == 0 else {'url': data[0][0], 'sprite': data[0][1], 'mood': data[0][2], 'size': [data[0][3], data[0][4]], 'hotspot': [data[0][5], data[0][6]]}
	def get_image(self, imageid):
		wake = (yield)
		return (yield from self._get_image(wake, imageid))
	def _add_image(self, wake, sprite, mood, url, size, hotspot):
		# TODO: load image and detect size.
		return (yield from serverdata.insert('image', {'sprite': sprite, 'mood': mood, 'url': url, 'width': size[0], 'height': size[1], 'hotx': hotspot[0], 'hoty': hotspot[1]}, wake = wake))
	def add_image(self, sprite, mood, url, size, hotspot):
		wake = (yield)
		return (yield from self._add_image(wake, sprite, mood, url, size, hotspot))
	def update_image(self, imageid, sprite, mood, url, size, hotspot):
		wake = (yield)
		# TODO: load image and detect size.
		if url is None:
			yield from serverdata.update('image', {'sprite': sprite, 'mood': mood, 'width': size[0], 'height': size[1], 'hotx': hotspot[0], 'hoty': hotspot[1]}, ('=', 'id', imageid), wake = wake)
		else:
			yield from serverdata.update('image', {'sprite': sprite, 'mood': mood, 'url': url, 'width': size[0], 'height': size[1], 'hotx': hotspot[0], 'hoty': hotspot[1]}, ('=', 'id', imageid), wake = wake)
	def remove_image(self, imageid):
		wake = (yield)
		yield from serverdata.delete('image', ('=', 'id', imageid), wake = wake)
	# }}}
	# Audio {{{
	def _list_audio(self, wake, chapter = None):
		if chapter is None:
			data = (yield from serverdata.select('audio', ('id', 'name', 'chapter', 'duration'), wake = wake))
			return {d[0]: {'name': d[1], 'chapter': d[2], 'duration': d[3]} for d in data}
		else:
			data = (yield from serverdata.select('audio', ('id', 'name', 'duration'), ('=', 'chapter', chapter), wake = wake))
			return {d[0]: {'name': d[1], 'duration': d[2]} for d in data}
	def list_audio(self):
		wake = (yield)
		return (yield from self._list_audio(wake))
	def _get_audio(self, wake, audioid):
		data = (yield from serverdata.select('audio', ('url',), ('=', 'id', audioid), wake = wake))
		return None if len(data) == 0 else data[0][0]
	def get_audio(self, audioid):
		wake = (yield)
		return (yield from self._get_audio(wake, audioid))
	def _add_audio(self, wake, name, chapter, url, duration):
		# TODO: load sound and detect duration.
		return (yield from serverdata.insert('audio', {'name': name, 'chapter': chapter, 'url': url, 'duration': duration}, wake = wake))
	def add_audio(self, name, chapter, url, duration):
		wake = (yield)
		return (yield from self._add_audio(wake, name, chapter, url, duration))
	def update_audio(self, audioid, name, chapter, url, duration):
		wake = (yield)
		# TODO: load sound and detect duration.
		if url is None:
			yield from serverdata.update('audio', {'name': name, 'chapter': chapter, 'duration': duration}, ('=', 'id', audioid), wake = wake)
		else:
			yield from serverdata.update('audio', {'name': name, 'chapter': chapter, 'url': url, 'duration': duration}, ('=', 'id', audioid), wake = wake)
	def remove_audio(self, audioid):
		wake = (yield)
		yield from serverdata.delete('audio', ('=', 'id', audioid), wake = wake)
	# }}}
	def import_chapter(self, zipdata): # {{{
		wake = (yield)
		errors = []
		z = zipfile.ZipFile(io.BytesIO(base64.b64decode(zipdata)), 'r')

		# Read metadata as list of lines. {{{
		metafiles = [x for x in z.infolist() if x.filename.endswith('/info.txt') and len(x.filename.split('/')) == 2]
		if len(metafiles) != 1:
			errors.append('Invalid chapter: must have exactly one metadata info file.')
			return errors
		meta = [x for x in z.read(metafiles[0]).decode('utf-8').split('\n') if x.strip() != '']
		# }}}

		# sprite <name>
		# mood <mood> size <w> <h> hotspot <x> <y>
		# audio <name> duration <duration>

		sprite = {}
		audio = {}
		# Parse metadata into useable structure. {{{
		current = None
		for line in meta:
			if len(line.strip()) == 0:
				continue
			parts = re.match('sprite (\S+)\s*$', line)
			if parts:
				name = parts.group(1)
				if name in sprite:
					errors.append('duplicate sprite in metadata: %s' % name)
					continue
				current = name
				sprite[current] = {}
				continue
			parts = re.match('mood (\S*) size (\S+) (\S+) hotspot (\S+) (\S+)\s*$', line)
			if parts:
				if current is None:
					errors.append('mood defined in metadata before sprite')
					continue
				name = parts.group(1)
				if name in sprite[current]:
					errors.append('duplicate mood %s defined for sprite %s' % (name, current))
					continue
				size = (float(parts.group(2)), float(parts.group(3)))
				hotspot = (float(parts.group(4)), float(parts.group(5)))
				sprite[current][name] = {'size': size, 'hotspot': hotspot}
				continue
			parts = re.match('audio (\S+) duration (\S+)\s*$', line)
			if parts:
				name = parts.group(1)
				if name in audio:
					errors.append('duplicate audio defined: %s' % name)
					continue
				audio[name] = float(parts.group(2))
				continue
			errors.append('imported content contains invalid metadata: %s' % line)
			continue
		# }}}

		chaptername = metafiles[0].filename.split('/')[0]
		chapterid = (yield from (self._add_chapter(wake, chaptername, None)))

		# Create all new sprites.
		for spritename in sprite:
			# Store the id in None, because string keys are mood names.
			sprite[spritename][None] = (yield from self._add_sprite(wake, spritename, chapterid))

		for info in z.infolist():
			parts = info.filename.split('/')
			if parts[0] != chaptername:
				errors.append('ignoring path with incorrect top level directory: %s != %s' % (parts[0], chaptername))
				continue
			target = parts[-1].rsplit('.', 1)
			if len(target) == 1:
				errors.append('ignoring path without extension: %s' % info.filename)
				continue
			if target[1] != 'txt':
				errors.append('ignoring non-txt extension: %s' % info.filename)
				continue
			target = target[0]

			# Do not attempt to parse the metadata here, it has been parsed above.
			if target == 'info':
				continue

			# Sprite mood image.
			if parts[1] == 'sprite':
				if len(parts) != 4:
					errors.append('ignoring path in imported zipfile: %s' % parts[1])
					continue
				if parts[2] not in sprite:
					errors.append('ignoring sprite without metadata: %s' % parts[2])
					continue
				if target not in sprite[parts[2]]:
					errors.append('ignoring sprite: mood is not defined in metadata: %s,%s' % (parts[2], target))
					continue
				s = sprite[parts[2]][target]
				yield from self._add_image(wake, sprite[parts[2]][None], target, z.read(info).decode('utf-8'), s['size'], s['hotspot'])
				continue

			# All other files need to have 3 path parts.
			if len(parts) != 3:
				errors.append('ignoring path in imported zipfile, because it does not have 3 parts: %s' % info.filename)
				continue

			# Script.
			if parts[1] == 'script':
				yield from self._add_script(wake, target, chapterid, z.read(info).decode('utf-8', 'replace'))

			# Audio.
			elif parts[1] == 'audio':
				if target not in audio:
					errors.append('ignoring audio without metadata: %s' % target)
					continue
				yield from self._add_audio(wake, target, chapterid, z.read(info).decode('utf-8'), audio[target])

			# Video (not implemented yet)
			elif parts[1] == 'video':
				errors.append('ignoring video path in imported zipfile (not implemented yet)')

			# Unsupported path.
			else:
				errors.append('ignoring unsupported path in imported zipfile: %s' % parts[1])
		return errors
	# }}}
	def export_chapter(self, chapterid): # {{{
		wake = (yield)
		chaptername = (yield from serverdata.select('chapter', ('name',), ('=', 'id', chapterid), wake = wake))[0][0]
		ret = io.BytesIO()
		z = zipfile.ZipFile(ret, 'w')
		images = {}
		info = b''
		for scriptid, data in (yield from self._list_scripts(wake)).items():
			script = (yield from self._get_script(wake, scriptid)).encode('utf-8')
			with z.open('%s/script/%s.txt' % (chaptername, data['name']), 'w') as f:
				f.write(script)
		for imageid, im in (yield from self._list_images(wake)).items():
			if im['sprite'] not in images:
				images[im['sprite']] = {}
			images[im['sprite']][im['mood']] = {'id': imageid, 'size': im['size'], 'hotspot': im['hotspot']}
		for spriteid, sprite in (yield from self._list_sprites(wake)).items():
			if sprite['chapter'] != chapterid:
				continue
			info += b'sprite %s\n' % sprite['name'].encode('utf-8')
			for mood in images[spriteid]:
				imageid = images[spriteid][mood]['id']
				url = (yield from self._get_image(wake, imageid))['url'].encode('utf-8')
				with z.open('%s/sprite/%s/%s.txt' % (chaptername, sprite['name'], mood), 'w') as f:
					f.write(url)
				info += b'mood %s size %f %f hotspot %f %f\n' % (mood.encode('utf-8'), images[spriteid][mood]['size'][0], images[spriteid][mood]['size'][1], images[spriteid][mood]['hotspot'][0], images[spriteid][mood]['hotspot'][1])
		for audioid, metadata in (yield from self._list_audio(wake, chapterid)).items():
			data = (yield from self._get_audio(wake, audioid)).encode('utf-8')
			if data is None:
				print('ignoring invalid audio id %s' % audioid)
				continue
			info += b'audio %s duration %f\n' % (metadata['name'].encode('utf-8'), metadata['duration'])
			with z.open('%s/audio/%s.txt' % (chaptername, metadata['name']), 'w') as f:
				f.write(data)
		with z.open('%s/info.txt' % chaptername, 'w') as f:
			f.write(info)
		z.close()
		return 'data:application/zip;base64,' + base64.b64encode(ret.getbuffer()).decode('utf-8')
	# }}}
# }}}

class Connection: # {{{
	# Internals. {{{
	def __init__(self, my_id, my_name, my_userdata, my_remote, managed_name): # {{{
		self.id = my_id
		self.name = my_name
		self.userdata = my_userdata
		self.remote = my_remote
		self.manged_name = managed_name
		self.display_name = my_name + (' (%s)' % managed_name if managed_name is not None else '')
	# }}}
	def _close(self): # {{{
		wake = (yield)
		del users[self.id]
		yield from refresh_admins(wake)
	# }}}
	def _init(self, wake): # {{{
		# Delayed contructor. Must be a generator.
		self._websocket_closed = self._close
		self.busy = False
		debug(2, 'New connection from {}:{}'.format(*self.remote.socket.remote))
		u = {}
		users[self.id] = u
		u['connection'] = self
		self.user = u
		data = (yield from self.userdata.select('id', ('my_name', 'my_group'), wake = wake))
		if len(data) == 0:
			groupname = (yield from serverdata.select('group', ('name',), ('=', 'id', 1), wake = wake))
			if len(groupname) == 0:
				groupname = ['']
			yield from self.userdata.insert('id', {'my_name': self.name, 'my_group': groupname[0][0]}, wake = wake)
			my_group = 1
		else:
			self.name = data[0][0]
			g = (yield from serverdata.select('group', ('id',), ('=', 'name', data[0][1]), wake = wake))
			if len(g) != 1:
				my_group = 1
			else:
				my_group = g[0][0]
		debug(1, 'User {}:{} logged in from {}:{}'.format(self.name, my_group, *self.remote.socket.remote))
		u['name'] = self.name
		u['group'] = my_group
		u['program'] = []
		u['run_stack'] = []
		u['chapter'] = None	# Current chapter.
		u['question'] = None	# Question that is currently being asked.
		scripts = (yield from content.list(wake, my_group))
		u['chapterprefix'] = []
		if len(scripts) > 0:
			while len(scripts[0]) > 1 and all(x[0] == scripts[0][0] for x in scripts):
				u['chapterprefix'].append(scripts[0][0])
				for s in scripts:
					s.pop(0)
		self.remote.contents.event(scripts)
		self.remote.main.event(self.display_name)
		yield from refresh_admins(wake)
	# }}}
	def _finish_login(self, wake = None): # {{{
		# TODO: This function is never called anymore. It should be called when (managed?) players reconnect.
		if wake is None:
			wake = (yield)
		if self.user['chapter'] is not None:
			if len(self.user['run_stack']) > 0 and len(self.user['run_stack'][-1]['program']) > 1:
				setup = []
				state = self.user['_kinetic_state']
				if state['background'] is not None:
					setup.append({'action': 'scene', 'target': state['background'], 'args': {'with': None}})
				for spr in state['sprite']:
					s = state['sprite'][spr]
					arg = {'action': 'move', 'target': spr, 'image': s['image']}
					arg.args = {x: s[x] for x in ('from', 'from_hotspot', 'to', 'to_hotspot', 'scale', 'scale_hotspot', 'rotation', 'rotation_hotspot')}
					arg.args.update({'with': None, 'around': None, 'in': None})
					setup.append(arg)
				self.remote.kinetic.event(setup, state['music'])
				if not (yield from self._run_item(wake, self.user['run_stack'][-1]['program'][self.user['run_stack'][-1]['current']])):
					debug(0, 'Bug: saved state of user {}:{} was not a waiting state'.format(name, group))
					yield from self._run(wake)
	# }}}
	def _safe_eval(self, expr, as_str): # {{{
		'Evaluate an expression through Lua.'
		ret = self.user['environment'].compute(expr, as_str)
		return str(ret) if as_str else ret
	# }}}
	def _parse_text(self, text): # {{{
		'Do substitutions on a text that is going to be shown to the user. This should be called with "yield from".'
		if text is None:
			return None
		result = ''
		for m in re.finditer('\${(.*?)}|[^$]+', text):
			if m.group(1) is None:
				# This is not a substitution; add the string to the result.
				result += m.group(0)
			else:
				# This is a substitution; add the evaluated string to the result.
				result += self._safe_eval(m.group(1), as_str = True)
		return result
	# }}}
	def _parse_time(self, t): # {{{
		'Parse a string (possibly including substitutions) as a time. Units of s for seconds or ms for milliseconds are required. This should be called with "yield from".'
		i = self._parse_text(t).strip()
		r = re.match(r'([-+.e0-9]+)\s*(m?)s$', i)
		if r is None:
			return None
		else:
			try:
				num = float(r.group(1))
				if r.group(2) == 'm':
					num /= 1e3
				return num
			except ValueError:
				debug(0, 'error parsing time {}'.format(i))
				return None
	# }}}
	def _answer(self, wake, style): # {{{
		'''Set style for last answer. This should be called with "yield from".'''
		if wake is None:
			wake = (yield)
		if self.user['question'] is None:
			debug(1, 'answer style given before a question was answered')
			return
		style = self._parse_text(style)
		yield from self.userdata.update('answer', {'style': style}, ('and', ('=', 'question', self.user['question']), ('=', 'script', self.user['scripttag'])), wake = wake)
		yield from refresh_admins(wake)
	# }}}
	def _sprite(self, tag, id, name, mood = ''): # {{{
		print('activating sprite', tag, name, id, mood)
		self.user['activesprite'][tag] = {'name': name, 'id': id, 'mood': mood}
	# }}}
	def _home(self, wake): # {{{
		self.user['chapter'] = None
		del self.user['environment']
		yield from refresh_admins(wake)
		self.remote.main.event(self.display_name)
	# }}}
	def _parse_animation_args(self, item_args): # {{{
		def parse_location(loc): # {{{
			'Parse location; return location and hotspot'
			if loc is None:
				return None, [0, 0]
			raw = self._parse_text(loc)
			if '@' in raw:
				h, pos = loc.split('@')
				hotspot = [float(x) for x in h.split(',')]
			else:
				pos = loc
				hotspot = [None, None]
			l = [x.strip() for x in pos.split(',')]
			h = [None, None]
			if l[0] == 'outleft':
				l[0] = -1
				h[0] = 1
			elif l[0] == 'inleft':
				l[0] = -1
				h[0] = -1
			elif l[0] == 'outright':
				l[0] = 1
				h[0] = -1
			elif l[0] == 'inright':
				l[0] = 1
				h[0] = 1
			elif l[0] == 'left':
				l[0] = -.4
				h[0] = 0
			elif l[0] == 'center':
				l[0] = 0
				h[0] = 0
			elif l[0] == 'right':
				l[0] = .4
				h[0] = 0
			else:
				try:
					l[0] = float(l[0])
				except:
					l[0] = 0
			if hotspot[0] is not None:
				h[0] = hotspot[0]
			if len(l) == 1:
				l.append(None)
			elif l[1] == 'outbottom':
				l[1] = 0
				h[1] = 1
			elif l[1] == 'inbottom':
				l[1] = 0
				h[1] = -1
			elif l[1] == 'outtop':
				l[1] = 1
				h[1] = -1
			elif l[1] == 'intop':
				l[1] = 1
				h[1] = 1
			elif l[1] == 'bottom':
				l[1] = 0
				h[1] = 0
			elif l[1] == 'low':
				l[1] = .2
				h[1] = 0
			elif l[1] == 'middle':
				l[1] = .5
				h[1] = 0
			elif l[1] == 'high':
				l[1] = .8
				h[1] = 0
			elif l[1] == 'top':
				l[1] = 1
				h[1] = 0
			else:
				try:
					l[1] = float(l[1])
				except:
					l[1] = None
			if hotspot[1] is not None:
				h[1] = hotspot[1]
			if len(l) == 2:
				l.append(None)
			else:
				try:
					l[2] = int(l[2])
				except:
					l[2] = None
			if h == [None, None]:
				h = None
			return l, h
		# }}}
		def parse_around(loc): # {{{
			if loc is None:
				return None
			l = [x.strip() for x in self._parse_text(loc).split()]
			if l[-1] in ('cw', 'ccw'):
				cw = l[-1] == 'cw'
				l.pop()
			else:
				cw = False
			if l[0] == 'left':
				l[0] = -.4
			elif l[0] == 'center':
				l[0] = 0
			elif l[0] == 'right':
				l[0] = .4
			else:
				try:
					l[0] = float(l[0])
				except:
					l[0] = 0
			if len(l) == 1:
				l.append(0)
			elif l[1] == 'bottom':
				l[1] = 0
			elif l[1] == 'low':
				l[1] = .2
			elif l[1] == 'middle':
				l[1] = .5
			elif l[1] == 'high':
				l[1] = .8
			elif l[1] == 'top':
				l[1] = 1
			else:
				try:
					l[1] = float(l[1])
				except:
					l[1] = 0
			return l[:2] + [cw]
		# }}}
		args = {}
		if item_args['in'] is None: # {{{
			args['in'] = None
		else:
			args['in'] = self._parse_time(item_args['in'])
		# }}}
		args['to'], args['to_hotspot'] = parse_location(item_args['to'])
		if args['in'] is None:
			args['with'] = 'jump'
			args['from'], args['from_hotspot'] = args['to'], args['to_hotspot']
		else:
			args['from'], args['from_hotspot'] = parse_location(item_args['from'])
		if args['from'] is not None:
			if args['from'][0] is None:
				args['from'][0] = 0
			if args['from'][1] is None:
				args['from'][1] = 0
		if item_args['with'] is None: # {{{
			args['with'] = 'move'
		else:
			w = self._parse_text(item_args['with'])
			if w not in ('jump', 'fade', 'move'):
				debug(0, 'invalid transition {}'.format(w))
				args['with'] = None
			else:
				args['with'] = w
		# }}}
		args['around'] = parse_around(item_args['around'])
		if item_args['scale'] is None: # {{{
			args['scale'] = None
			args['scale_hotspot'] = None
		else:
			raw = self._parse_text(item_args['scale'])
			if '@' in raw:
				value, hotspot = raw.split('@')
				s = [x.strip() for x in value.split(',')]
				h = [x.strip() for x in hotspot.split(',')]
			else:
				s = [x.strip() for x in raw.split(',')]
				h = None
			try:
				def parse(num):
					if num.endswith('%'):
						return float(num[:-1]) / 100
					return float(num)
				s = [parse(x) for x in s]
				if len(s) == 1:
					s.append(s[0])
				elif len(s) > 2:
					s = [s[0], s[1]]
			except:
				debug(0, 'error parsing scale {}'.format(s))
				s = None
			args['scale'] = s
			args['scale_hotspot'] = h
		# }}}
		if item_args['rotation'] is None: # {{{
			args['rotation'] = None
			args['rotation_hotspot'] = None
		else:
			raw = self._parse_text(item_args['rotation']).strip()
			if '@' in raw:
				r, hotspot = raw.split('@')
				h = [x.strip() for x in hotspot.split(',')]
			else:
				r = raw
				h = None
			if r.endswith('°'):
				f = 360
				r = r[:-1]
			else:
				f = 1
			try:
				r = float(r) / f
			except:
				debug(0, 'error parsing rotation {}'.format(r))
				r = None
			args['rotation'] = r
			args['rotation_hotspot'] = h
		# }}}
		return args
	# }}}
	def _continue_break(self, cmd): # {{{
		while self.user['run_stack'][-1]['current'] >= len(self.user['run_stack'][-1]['program']) or self.user['run_stack'][-1]['program'][self.user['run_stack'][-1]['current']]['command'] != 'while':
			self.user['run_stack'].pop()
		if cmd == 'break':
			self.user['run_stack'][-1]['current'] += 1
	# }}}
	def _goto(self, target): # {{{
		# Break to top level and jump to requested label.
		while len(self.user['run_stack']) > 1:
			self.user['run_stack'].pop()
		self.user['run_stack'][-1]['current'] = target
	# }}}
	def _clear_pending(self): # {{{
		# update kinetic state.
		def handle_action(action, state):
			if action['action'] in ('speech', 'sound', 'wait'):
				# Nothing to update.
				pass
			elif action['action'] == 'scene':
				state['background'] = action['target']
			elif action['action'] == 'music':
				state['music'] = action['target']
			elif action['action'] in ('serial', 'parallel'):
				for a in action['actions']:
					handle_action(a, state)
			elif action['action'] == 'hide':
				del state['sprite'][action['target']]
			else:
				assert action['action'] == 'move'

				# If target sprite does not exist, create it (with no image).
				if action['target'] not in state['sprite']:
					state['sprite'][action['target']] = {'from': [0, 0, None], 'from_hotspot': None, 'to': [0, 0, None], 'to_hotspot': None, 'scale': None, 'scale_hotspot': None, 'rotation': None, 'rotation_hotspot': None, 'image': None}
				# Store target sprite in local variable.
				target = state['sprite'][action['target']]

				# Set mood image.
				target['target'] = action['target']
				target['mood'] = action['mood']
				args = action['args']
				for prop in ('from', 'from_hotspot', 'to', 'to_hotspot', 'scale', 'scale_hotspot', 'rotation', 'rotation_hotspot'):
					if args.get(prop) is not None:
						target[prop] = args[prop]
		for action in self.user['_pending']:
			handle_action(action, self.user['_kinetic_state'])
		#debug(0, repr(self.user['_pending']))
		self.user['_pending'] = []
	# }}}
	def _start(self, wake, script_content, send_errors): # {{{
		self.user['program'], errors, question, self.user['labels'] = script_content
		if send_errors:
			if len(errors) > 0:
				errors = markdown('# Errors:\n' + '\n\n'.join(errors))
			else:
				errors = ''
			self.remote.error.event(errors)
		self.user['run_stack'] = [{'program': self.user['program'], 'current': 0}]
		# Sprites are stored in two steps.
		# All available sprites are loaded into user['sprite'] by this function.
		# All active sprites (declared with a "sprite" command, may or may not be onscreen) are in user['activesprite']. Both are dicts.
		# user['sprite'] has sprite names (as defined in db) as keys. Its values are dicts with mood names as keys and their numerical image ids as values.
		# user['activesprite'] has tags as used in the script as keys. Its values are dicts with items:
		#   'name': The character's name that is shown on screen as the speaker name,
		#   'id': The db sprite name, which is used as the key in user['sprite'] and
		#   'mood': The currently active mood, for when there is speech without an explicit mood.
		self.user['sprite'] = {}
		self.user['activesprite'] = {}
		self.user['_pending'] = []
		self.user['question'] = None
		# Set up self.user['sprite']. {{{
		global_sprites = (yield from serverdata.select('sprite', ('id', 'name'), ('=', 'chapter', None), wake = wake))
		local_sprites = (yield from serverdata.select('sprite', ('id', 'name'), ('=', 'chapter', self.user['chapter']), wake = wake))
		spriteid = {name: id for id, name in global_sprites}
		spriteid.update({name: id for id, name in local_sprites})
		for name in spriteid:
			id = spriteid[name]
			moods = (yield from serverdata.select('image', ('mood', 'id'), ('=', 'sprite', id), wake = wake))
			self.user['sprite'][name] = {m[0]: m[1] for m in moods}
		sprites = {name: list(self.user['sprite'][name].keys()) for name in spriteid}
		# }}}
		# Set up self.user['audio']. {{{
		global_audio = (yield from serverdata.select('audio', ('id', 'name'), ('=', 'chapter', None), wake = wake))
		local_audio = (yield from serverdata.select('audio', ('id', 'name'), ('=', 'chapter', self.user['chapter']), wake = wake))
		audioid = {name: id for id, name in global_audio}
		audioid.update({name: id for id, name in local_audio})
		self.user['audio'] = audioid
		# }}}
		self.user['environment'] = Environment()
		module = {
			'name': self.user['name'],
			'group': self.user['group'],
			'chapter': self.user['chapter'],
			'script': self.user['script'],
			# Available sprites and moods. Example: {'person': ['', 'happy', 'sad'], 'bg': ['', 'inside', 'outside']}
			'allsprites': sprites,
			# Active sprites. This object can be manipulated to change the appearance of the sprite (speaker name and image collection; mood is changed through kinetic commands).
			'activesprites': self.user['activesprite'],
			# Available audio.
			'audio': list(self.user['audio'].keys()),

			# These are handled immediately.
			# Record answer style
			'answer': lambda style: (yield from self._answer(None, style)),
			# Activate a sprite. call as sprite(tag, name, id, mood). Using lambda to make sure it's not a member.
			'sprite': lambda tag, id, name, mood = '': self._sprite(tag, id, name, mood),
			# Add kinetic commands to the pending queue.
			'kinetic': lambda actions: self.user['_pending'].extend(actions),

			# These are used for building kinetic commands.
			'speech': lambda speaker, target, mood, side, text: {'action': 'speech', 'speaker': speaker, 'target': target, 'mood': mood, 'side': side, 'text': markdown(text)},
			'wait': lambda seconds: {'action': 'wait', 'time': seconds},
			'sound': lambda tag: {'action': 'sound', 'tag': tag},
			'music': lambda tag: {'action': 'music', 'tag': tag},
			'serial': lambda *parts: {'action': 'serial', 'parts': parts},
			'parallel': lambda *parts: {'action': 'parallel', 'parts': parts},
			'move': lambda target, mood, args: {'action': 'move', 'target': target, 'mood': mood, 'args': self._parse_animation_args(args)},
			'hide': lambda target, mood, args: {'action': 'hide', 'target': target, 'mood': mood, 'args': self._parse_animation_args(args)},

			# These can be returned.
			'video': lambda tag: {'cmd': 'video', 'video': tag},
			'question': lambda tag, type, text, options = None: {'cmd': 'question', 'tag': tag, 'type': type, 'text': text, 'options': options},
			'continue': lambda: {'cmd': 'continue'},
			'break': lambda: {'cmd': 'break'},
			'goto': lambda label: {'cmd': 'goto', 'label': label}
		}
		self.user['environment'].module('vn', module)

		startup = fhs.read_data(os.path.join('include', 'startup.lua'))
		if startup is not None:
			try:
				self.user['environment'].run(startup.read(), False)
			except:
				debug(1, 'Error in startup script')
				traceback.print_exc()
		yield from self._run(wake)
	# }}}
	def _question(self, wake, qtype, variable, markdown, options): # {{{
		# Handle hidden type differently (don't inform player).
		if qtype == 'hidden':
			self._store_answer(variable, self._safe_eval(markdown, as_str = True))
			return False

		# Find last answer.
		answers = (yield from self.userdata.select('answer', ('answer',), ('and', ('=', 'script', self.user['scripttag']), ('=', 'question', variable)), wake = wake))
		if len(answers) == 0:
			last_answer = None
		else:
			last_answer = json.loads(answers[-1][0])

		# Modify type to make it easier for brower code.
		if qtype == 'unit':
			qtype = 'short'
		if qtype == 'longunit':
			qtype = 'longshort'
		qtext = self._parse_text(markdown)

		# Parse options.
		parsed_options = []
		if options is not None:
			for x in options:
				parsed_options.append(self._parse_text(x))

		# Send question to player.
		self.remote.question.event(self.user['_pending'], qtext, qtype, parsed_options, last_answer)

		return True
	# }}}
	def _run(self, wake): # {{{
		watchdog = 0
		while len(self.user['run_stack']) > 0:
			watchdog += 1
			if watchdog > 1000:
				debug(1, 'hanging script detected: {}; killing it'.format(self.user['chapter']))
				self.remote.error.event(['Script stopped working and was killed.'])
				self.user['run_stack'] = [{'program': self.user['program'], 'current': len(self.user['program'])}]
				yield from refresh_admins(wake)
				return
			# Pop off stack levels until there's an instruction.
			while len(self.user['run_stack'][-1]['program']) <= self.user['run_stack'][-1]['current']:
				self.user['run_stack'].pop()
				#print('pop', self.user['run_stack'])
				if len(self.user['run_stack']) == 0:
					# Send final "question".
					self.remote.question.event(self.user['_pending'], '', 'choice', ['Done'])
					yield from refresh_admins(wake)
					return
			# Run instructions.
			if (yield from self._run_item(wake, self.user['run_stack'][-1]['program'][self.user['run_stack'][-1]['current']])):
				#print('break')
				break
			#print('no break')
		yield from refresh_admins(wake)
	# }}}
	def _run_item(self, wake, code): # {{{
		debug(3, '{}:{} running item {}'.format(self.user['name'], self.user['group'], repr(code)))
		if code['command'] == 'label': # {{{
			pass
		# }}}
		elif code['command'] == 'answer': # {{{
			yield from self._answer(wake, code['answer'])
		# }}}
		elif code['command'] == 'if': # {{{
			self.user['run_stack'][-1]['current'] += 1
			for expr, target in code['code']:
				if expr is None or self._safe_eval(expr, as_str = False):
					self.user['run_stack'].append({'program': target, 'current': 0})
					break
			return False
		# }}}
		elif code['command'] == 'while': # {{{
			# Don't increment instruction pointer, so the loop restarts.
			if self._safe_eval(code['test'], as_str = False):
				self.user['run_stack'].append({'program': code['code'], 'current': 0})
			else:
				# exit the while loop.
				self.user['run_stack'][-1]['current'] += 1
				# handle else clause, if present.
				if code['else'] is not None:
					self.user['run_stack'].append({'program': code['else'], 'current': 0})
			return False
		# }}}
		elif code['command'] in ('continue', 'break'): # {{{
			self._continue_break(code['command'])
			return False
		# }}}
		elif code['command'] == 'goto': # {{{
			self._goto(code['target'])
			return False
		# }}}
		elif code['command'] == 'code': # {{{
			self.user['run_stack'][-1]['current'] += 1	# Do this before running the code, so goto works.
			try:
				cmd = self.user['environment'].run(code['code'])
			except:
				debug(0, 'Error in script: {}'.format(code['code']))
				traceback.print_exc()
				self.remote.error.event(code['code'])
			if isinstance(cmd, dict):
				if cmd['cmd'] == 'video':
					self.remote.video.event(self.user['_pending'], cmd['video'])
					return True
				elif cmd['cmd'] == 'question':
					return (yield from self._question(wake, cmd['type'], cmd['variable'], code['markdown'], code['option']))
				elif cmd['cmd'] in ('continue', 'break'):
					self._continue_break(cmd['cmd'])
					return False
				elif cmd['cmd'] == 'goto':
					self._goto(self.user['labels'][cmd['label']])
					return False
			return False
		# }}}
		elif code['command'] == 'video': # {{{
			self.remote.video.event(self.user['_pending'], code['video'])
			return True
		# }}}
		elif code['command'] == 'sprite': # {{{
			self._sprite(code['tag'], self._parse_text(code['images']), self._parse_text(code['name']))
		# }}}
		elif code['command'] == 'kinetic': # {{{
			def build_kinetic(wake, item): # {{{
				if item['action'] == 'speech': # {{{
					target = item['speaker']
					#print('check', item, self.user['activesprite'])
					speaker = None if target is None else self.user['activesprite'][target]['name'] if target in self.user['activesprite'] else '(' + target + ')'
					if target in self.user['activesprite']: # {{{
						# Target is an active sprite (defined in the script).
						spriteid = self.user['activesprite'][target]['id']
						if spriteid in self.user['sprite']: # {{{
							# Target is a sprite (not an invalid active sprite).
							sprite = self.user['sprite'][spriteid]
							if item['mood'] not in sprite: # {{{
								# Requested mood does not exist.
								mood = None
							else:
								# Requested mood exists; use it.
								mood = item['mood']
							# }}}
						else:
							# Target is not a sprite (invalid name defined in script): no images.
							mood = None
						# }}}
					else:
						# Target is not an active sprite (not defined in script): no images.
						mood = None
					# }}}
					if 'side' in self.user['activesprite'][target]:
						side = self.user['activesprite'][target]['side']
					else:
						side = None
					return {'action': 'speech', 'speaker': speaker, 'target': target, 'mood': mood, 'side': side, 'text': markdown(self._parse_text(item['markdown']))}
				# }}}
				if item['action'] == 'wait': # {{{
					return {'action': 'wait', 'time': self._parse_time(item['time'])}
				# }}}
				if item['action'] in ('sound', 'music'): # {{{
					target = None if item['target'] is None else self._parse_text(item['target'])
					return {'action': item['action'], 'target': target}
				# }}}
				if item['action'] in ('serial', 'parallel'): # {{{
					actions = []
					for x in item['actions']:
						actions.append((yield from build_kinetic(wake, x)))
					return {'action': item['action'], 'args': item['args'], 'actions': actions}
				# }}}
				# Something else: move, or hide.
				args = self._parse_animation_args(item['args'])
				if item['target'] is None: # {{{
					target = None
					mood = None
				else:
					target = self._parse_text(item['target'])
					mood = self._parse_text(item['mood'])
				# }}}
				#print('returning build', item['action'])
				return {'action': item['action'], 'target': target, 'mood': mood, 'args': args}
			# }}}
			actions = []
			for x in code['kinetic']:
				#print('building', x)
				actions.append((yield from build_kinetic(wake, x)))
			self.user['_pending'].extend(actions)
			#print('now pending:', self.user['_pending'])
		# }}}
		elif code['command'] == 'question': # {{{
			self.user['run_stack'][-1]['current'] += 1
			return (yield from self._question(wake, code['type'], code['variable'], code['markdown'], code['option']))
		# }}}
		else:
			debug(0, 'invalid command {}'.format(code))
		self.user['run_stack'][-1]['current'] += 1
		return False
	# }}}
	def _update_sprite(self, tag, data): # {{{
		for item in ('x', 'y', 'mood'):
			if item in data:
				self.user['characters'][tag][item] = data[item]
		c = self.user['characters'][tag]
		data['url'] = c['imgs'] + (data.pop('mood') if 'mood' in data else 'default') + c['ext']
	# }}}
	def _store_answer(self, question, answer, store = True): # {{{
		self.user['environment'].set(question, answer)
		if store:
			self.userdata.insert('answer', {'script': self.user['scripttag'], 'question': question, 'answer': json.dumps(answer)})
			self.user['question'] = question
		else:
			self.user['question'] = None
	# }}}
	# }}}
	def get_sprite_image(self, sprite_tag, sprite_mood): # {{{
		'Retrieve image from database. Return data url.'
		wake = (yield)
		#print('getting image for sprite', repr(sprite_tag), repr(sprite_mood))
		if sprite_tag in self.user['activesprite']:
			sprite_name = self.user['activesprite'][sprite_tag]['id']
		else:
			sprite_name = sprite_tag
		if sprite_name in self.user['sprite']:
			if sprite_mood in self.user['sprite'][sprite_name]:
				imageid = self.user['sprite'][sprite_name][sprite_mood]
			elif '' in self.user['sprite'][sprite_name]:
				imageid = self.user['sprite'][sprite_name]['']
			else:
				imageid = None
		else:
			s = self.user['sprite']['']
			if sprite_mood in s:
				imageid = s[sprite_mood]
			elif '' in s:
				imageid = s['']
			else:
				imageid = None
		data = (yield from serverdata.select('image', ('url', 'width', 'height', 'hotx', 'hoty'), ('=', 'id', imageid), wake = wake))
		if len(data) != 1:
			print('Warning: sprite %s mood %s not found and no fallback found either' % (sprite_tag, sprite_mood))
			return {'url': None, 'size': (0, 0), 'hotspot': (0, 0)}
		#print('image id', imageid, 'from', repr(self.user['sprite']), 'data', data[0][0][:30])
		return {'url': data[0][0], 'size': (data[0][1], data[0][2]), 'hotspot': (data[0][3], data[0][4])}
	# }}}
	def get_audio(self, audioid): # {{{
		'Retrieve audio from database. Return data url.'
		wake = (yield)
		if audioid not in self.user['audio']:
			log('invalid audio tag %s requested' % audioid)
		data = (yield from serverdata.select('audio', ('url', 'duration'), ('=', 'id', self.user['audio'][audioid]), wake = wake))
		if len(data) != 1:
			log('failed to get audio %s (id %d)' % (audioid, self.user['audio'][audioid]))
			return None
		return {'url': data[0][0], 'duration': data[0][1]}
	# }}}
	def home(self): # {{{
		wake = (yield)
		if self.busy and not force:
			traceback.print_stack()
			log('attempt to home while busy')
			return
		yield from self._home(wake)
	# }}}
	def start(self, script): # {{{
		wake = (yield)
		if self.busy:
			log('attempt to start while busy')
			traceback.print_stack()
			return
		self.user['_kinetic_state'] = {'background': None, 'sprite': {}, 'music': None}
		self.busy = True
		chapterid, scriptid, code = (yield from content.get(wake, self.user['group'], self.user['chapterprefix'] + script))
		self.user['scripttag'] = '\t'.join(script)
		self.user['chapter'] = chapterid
		self.user['script'] = scriptid
		try:
			yield from self._start(wake, code, False)
		finally:
			self.busy = False
	# }}}
	def answer(self, answer): # {{{
		wake = (yield)
		if self.busy:
			log('attempt to answer while busy')
			return
		self._clear_pending()
		debug(3, '{}:{} answers {}'.format(self.user['name'], self.user['group'], answer))
		if len(self.user['run_stack']) == 0:
			# Ignore answer for final "Done" button.
			yield from self._home(wake)
			return
		if self.user['run_stack'][-1]['current'] >= len(self.user['run_stack'][-1]['program']):
			self.busy = True
			try:
				yield from self._run(wake)
			finally:
				self.busy = False
			return
		current = self.user['run_stack'][-1]['program'][self.user['run_stack'][-1]['current']]
		if current['type'] not in ('short', 'long', 'choice', 'unit', 'longshort', 'longunit', 'longchoice'):
			debug(1, 'answer given by {}:{} for non-question: {}'.format(self.remote.socket.remote[0], self.remote.socket.remote[1], current))
			return
		store = not current['variable'].startswith('_')
		def parse_unit(src):
			r = re.match(r'\s*(?:(\S+)\s*=\s*)?([+-]?[0-9]*(?:[.,]\d*)?)(?:·10([⁻⁺]?[⁰¹²³⁴⁵⁶⁷⁸⁹]+))?\s*(\S*)\s*$', src)
			# groups:
			# 1: quantity	(\S+)
			# 2: base value	([+-]?[0-9]*(?:[.,]\d*)?)
			# 3: exponent	(·10([⁻⁺]?[⁰¹²³⁴⁵⁶⁷⁸⁹]+))?
			# 4: unit	(\S*)
			if not r or r.group(1) is None:
				debug(3, 'no match for unit answer')
				answer = {'quantity': None, 'unit': None, 'digits': None, 'value': None}
			else:
				try:
					answer = {}
					answer['quantity'] = r.group(1)
					base = r.group(2).replace(',', '.')
					exponent = None if r.group(3) is None else int(fromsuper(r.group(3)))
					answer['unit'] = r.group(4)
					answer['digits'] = len(base.replace('.', '').lstrip('0'))
					answer['value'] = float(base) * (1 if exponent is None else 10 ** exponent)
				except:
					traceback.print_exc()
					answer = {'quantity': None, 'unit': None, 'digits': None, 'value': None}
			debug(3, 'unit-split answer: {}'.format(answer))
			return answer
		raw = answer
		if current['type'] == 'choice':
			if isinstance(answer, int) and 1 <= answer <= len(current['option']):
				answer = {'index': answer, 'text': current['option'][answer - 1]}
			else:
				answer = {}
			if len(current['option']) <= 1:
				store = False
		elif current['type'] == 'longchoice':
			if isinstance(answer[0], int) and 1 <= answer[0] <= len(current['option']):
				answer = {'index': answer[0], 'text': current['option'][answer[0] - 1], 'long': str(answer[1]).strip()}
			else:
				# Leave answer string as is (but force str); this only happens when users are messing with the js.
				debug(2, 'unparsable longchoice answer: {}'.format(answer))
				answer = {'choice': None, 'long': str(answer).strip()}
		elif current['type'] == 'unit':
			answer = parse_unit(answer)
		elif current['type'] == 'longunit':
			l = answer[1]
			try:
				answer = parse_unit(answer[0])
				answer['long'] = l
			except:
				# Leave answer string as is (but force str); this only happens when users are messing with the js.
				debug(2, 'unparsable longunit answer: {}'.format(answer))
				answer = {}
		elif current['type'].startswith('long') and current['type'] != 'long':
			try:
				answer = {'text': str(answer[0]).strip(), 'long': str(answer[1]).strip()}
			except:
				# Leave answer string as is (but force str); this only happens when users are messing with the js.
				debug(2, 'unparsable long* answer: {}'.format(answer))
				answer = {}
		else:
			answer = {'text': answer}
		answer['raw'] = raw
		answer['style'] = []
		self._store_answer(current['variable'], answer, store)
		self.user['run_stack'][-1]['current'] += 1
		self.busy = True
		try:
			yield from self._run(wake)
		finally:
			self.busy = False
	# }}}
	def video_done(self): # {{{
		wake = (yield)
		if self.busy:
			log('attempt to finish video while busy')
			return
		self._clear_pending()
		if self.user['run_stack'][-1]['current'] >= len(self.user['run_stack'][-1]['program']):
			self.busy = True
			try:
				yield from self._run(wake)
			finally:
				self.busy = False
			return
		current = self.user['run_stack'][-1]['program'][self.user['run_stack'][-1]['current']]
		if current[0] == 'video':
			self.user['run_stack'][-1]['current'] += 1
			self.busy = True
			try:
				yield from self._run(wake)
			finally:
				self.busy = False
	# }}}
# }}}

def connection_selector(my_id, my_name, my_userdata, my_remote, managed_name): # {{{
	parts = my_remote.data['url'].strip('/').split('/')
	# example parts: ['content', 'index.html', 'websocket']
	if len(parts) > 2:
		if parts[-3] == 'admin':
			return Admin_Connection(my_id, my_name, my_userdata, my_remote, managed_name)
		if parts[-3] == 'content':
			return Content_Connection(my_id, my_name, my_userdata, my_remote, managed_name)
	return Connection(my_id, my_name, my_userdata, my_remote, managed_name)
# }}}

db_config = { # {{{
	# Permissions # {{{
	'group': [
		('id', 'int(11) NOT NULL AUTO_INCREMENT PRIMARY KEY'),
		('name', 'text NOT NULL')
	],
	'chapter': [
		('id', 'int(11) NOT NULL AUTO_INCREMENT PRIMARY KEY'),
		('name', 'text NOT NULL'),
		('parent', 'int(11) DEFAULT NULL'),
	],
	'access': [
		('groupid', 'int(11) NOT NULL'),
		('chapter', 'int(11) DEFAULT NULL'),
	],
	# }}}

	# Scripts {{{
	'script': [
		('id', 'int(11) NOT NULL AUTO_INCREMENT PRIMARY KEY'),
		('name', 'text NOT NULL'),
		('chapter', 'int(11) NOT NULL'),
		('script', 'longtext NOT NULL')
	],
	'question': [
		('id', 'text NOT NULL'),
		('script', 'int(11) NOT NULL'),
		('type', 'varchar(255) NOT NULL'),
		('description', 'varchar(255) NOT NULL')
	],
	# }}}

	# Images {{{
	'sprite': [
		('id', 'int(11) NOT NULL AUTO_INCREMENT PRIMARY KEY'),	# Sprite id.
		('name', 'text NOT NULL'),	# Sprite name.
		('chapter', 'int(11) DEFAULT NULL'),	# Chapter id, or NULL for global sprites.
	],
	'image': [
		('id', 'int(11) NOT NULL AUTO_INCREMENT PRIMARY KEY'),
		('sprite', 'int(11) NOT NULL'),	# Sprite id.
		('mood', 'text NOT NULL'),	# Mood name.
		('url', 'longtext NOT NULL'),	# Data url.

		# Size of image in screen units.
		('width', 'float NOT NULL'),
		('height', 'float NOT NULL'),

		# Location of hotspot in screen units.
		# The origin for the hotspot coordinates is the bottom left corner of the image.
		('hotx', 'float NOT NULL'),
		('hoty', 'float NOT NULL'),
	],
	# }}}

	# Media {{{
	'audio': [
		('id', 'int(11) NOT NULL AUTO_INCREMENT PRIMARY KEY'),
		('chapter', 'int(11) DEFAULT NULL'),
		('name', 'varchar(255) NOT NULL'),
		('url', 'longtext NOT NULL'),	# Data url.
		('duration', 'int(11) NOT NULL'),
	],
	# }}}
} # }}}
player_config = { # {{{
	'id': [	# This table has only one row.
		('my_name', 'varchar(255) NOT NULL'),
		('my_group', 'varchar(255) NOT NULL')
	],
	'answer': [
		('script', 'mediumtext NOT NULL'),	# tab-separated list of chapters.
		('question', 'text NOT NULL'),
		('answer', 'longblob NOT NULL'),
		('style', 'mediumtext DEFAULT NULL')
	]
} # }}}

# Main program {{{
server, serverdata = userdata.setup(connection_selector, config, db_config, player_config, httpdirs = ('html',), proxy = config['proxy'])
content.init(serverdata)

print('server is running on port {}'.format(config['port']))
websocketd.fgloop()
# }}}

# vim: set foldmethod=marker :
