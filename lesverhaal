#!/usr/bin/python3
# vim: set fileencoding=utf-8 :

# Imports and config. {{{
import sys
import os
import math
import re
import traceback
import time
import random
import fhs
import websocketd
import json
import userdata
import content
from markdown import markdown
from websocketd import log

fhs.option('port', 'network port to listen for players', default = '7000')
fhs.option('proxy', 'virtual proxy directory', default = 'lesverhaal')
fhs.option('logfile', 'file for logging events', default = '')
fhs.option('loglimit', 'maximum loglevel that is written to screen', default = 1)
config = userdata.fhs_init('http://localhost:8879', 'lesverhaal', help = 'Visual novel style tool for students to learn with teacher monitoring options', contact = 'Bas Wijnen <wijnen@debian.org>', version = '0.2')
from debug import debug
# }}}

''' Log priorities: {{{
		0: Critical (system code errors)
		1: Important (user code errors)
		2: Normal (communication notifications)
		3: Debug
}}} '''

# Sub-/superscript helpers. {{{
tosuper_dict = {'0': '⁰', '1': '¹', '2': '²', '3': '³', '4': '⁴', '5': '⁵', '6': '⁶', '7': '⁷', '8': '⁸', '9': '⁹', '-': '⁻', '+': '⁺', '=': '⁼', '(': '⁽', ')': '⁾', 'n': 'ⁿ'}
def tosuper(src):
	return ''.join(tosuper_dict.get(c, c) for c in src)

fromsuper_dict = {v: k for k, v in tosuper_dict.items()}
def fromsuper(src):
	return ''.join(fromsuper_dict.get(c, c) for c in src)
# }}}

# List of all currently logged in users.
users = {}

class Admin_Connection: # {{{ Class for handling admin connections.
	def __init__(self, my_id, my_name, my_userdata, my_remote, managed_name): # {{{
		self.id = my_id
		self.name = my_name
		self.userdata = my_userdata
		self.remote = my_remote
		self.remote.closed = self._closed
	# }}}
	def _init(self, wake): # {{{
		self.user = None
		self.refresh = lambda: self.remote.login.event()
		self.remote.login.event()
	# }}}
	def login(self, name, password): # {{{
		u = user.load(name.strip(), 'admin')
		if u is None:
			debug(2, 'Invalid admin {} from {}:{}'.format(name, *self.remote.socket.remote))
			return False
		crypted = crypt(password, salt = u['password'])
		if crypted != u['password']:
			debug(2, 'Invalid password for {} from {}:{}'.format(name, *self.remote.socket.remote))
			return False
		if not self._login(name.strip()):
			debug(2, 'Login failed for other reason')
			self.remote.login.event()
			self.refresh = lambda: self.remote.login.event()
		debug(2, 'login function returns')
		return True
	# }}}
	def _login(self, name): # {{{
		u = user.load(name, 'admin')
		if u is None:
			return False
		if u['connection'] is not None:
			debug(3, 'Replacing connection for ' + name)
			try:
				u['connection'].remote.replaced.event()
			except:
				pass
			u['connection'].remote.close()
		users[(u['filename'], 'admin')] = u
		u['connection'] = self
		self.user = u
		debug(1, 'Admin {} logged in from {}:{}'.format(name, *self.remote.socket.remote))
		user.admins[name.lower()] = self
		self.list_groups()
		return True
	# }}}
	def _closed(self): # {{{
		self.remote.close()
		if self.user is None:
			debug(2, 'admin connection to {}:{} lost before logging in'.format(*self.remote.socket.remote))
			return
		debug(1, 'disconnecting admin {}'.format(self.user['name']))
		try:
			users.pop((self.user['filename'], 'admin'))
		except:
			pass
		try:
			user.admins.pop(self.user['filename'])
		except:
			pass
	# }}}
	def list_groups(self): # {{{
		'''Show selection of groups to choose.'''
		assert self.user is not None
		self.refresh = lambda: self.list_groups()
		groups = []
		for g in os.listdir(os.path.join(config['data'], 'users')):
			if g == 'admin' or g.lower() != g:
				continue
			groups.append([g])
			chapters = content.list(wake, g)
			keys = list(chapters.keys())
			keys.sort()
			for c in keys:
				for s in chapters[c]:
					groups[-1].append(((c, s), sum(users[u]['group'].lower() == g and users[u]['chapter'] == (c, s) for u in users)))
		groups.sort()
		self.remote.group_list.event(groups)
	# }}}
	def show_chapter(self, group, chapter): # {{{
		'''Show questions for one chapter.'''
		assert self.user is not None
		chapter = tuple(chapter)
		self.refresh = lambda: self.show_chapter(group, chapter)
		parts, errors = content.get(wake, group, chapter)
		questions = []
		def add_block(block):
			for p in block:
				if p['command'] == 'while':
					add_block(p['code'])
				elif p['command'] == 'if':
					for b in p['code']:
						add_block(b[1])
				elif p['command'] == 'video':
					questions.append({'type': 'video', 'name': 'video', 'markdown': p['video'], 'option': None, 'line': p['line']})
				elif p['command'] == 'question':
					questions.append({'type': p['type'], 'name': p['variable'], 'markdown': p['markdown'], 'option': p['option'], 'line': p['line']})
		add_block(parts)
		questions.append({'type': 'end', 'name': '', 'markdown': '', 'option': None, 'line': math.nan})
		students = []
		def make_field(student, question):
			active = False
			if student['chapter'] == chapter:
				if len(student['run_stack']) > 0:
					frame = student['run_stack'][-1]
					if len(frame['program']) > frame['current']:
						if frame['program'][frame['current']]['line'] == question['line']:
							active = True
				elif question['type'] == 'end':
					active = True
			return {'active': active, 'attempts': student['answers'][chapter][question['name']] if question['type'] not in ('video', 'end') and chapter in student['answers'] and question['name'] in student['answers'][chapter] else None}
		def make_other_field(student, question):
			return {'active': False, 'attempts': student['answers'][chapter][question['name']] if question['type'] not in ('video', 'end') and chapter in student['answers'] and question['name'] in student['answers'][chapter] else None}
		for s in users:
			if users[s]['group'].lower() != group.lower():
				continue
			students.append({'password': bool(users[s]['password']), 'name': users[s]['name'], 'code': s, 'login': users[s]['chapter'] == chapter, 'connected': users[s]['connection'] is not None, 'answers': tuple(make_field(users[s], q) for q in questions)})
		students.sort(key = lambda s: (not s['login'], s['name'], s['code']))
		# Add non-connected students to the list.
		others = []
		for u in user.list_group(group):
			if (u, group) in users:
				continue
			student = user.load(u, group)
			if student is None:
				debug(0, 'student found but unloadable: {}:{}'.format(u, group))
				continue
			others.append({'password': bool(student['password']), 'name': student['name'], 'code': u, 'login': None, 'connected': False, 'answers': tuple(make_other_field(student, q) for q in questions)})
		try:
			others.sort(key = lambda s: (s['name'], s['code']))
		except:
			pass
		students.extend(others)
		self.remote.students_list.event(group, questions, students)
	# }}}
	def reset_password(self, student, group): # {{{
		assert self.user is not None
		u = user.load(student, group)
		assert u is not None
		u['password'] = None
		user.save(u)
	# }}}
# }}}

def refresh_admins(): # {{{
	# TODO: part of admin reimplementation.
	pass
# }}}

# Class for handling user script commands. {{{
# There can be multiple implementations of te Environment class.
# Only Lua is defined. This is not expected to change.
# It needs to define:
# - constructor with no arguments (or no constructor).
# - set(self, key, value):
#	Set a value in the game's namespace.
# - run(self, wake, script, allow_ui = True):
#	Run code in the game's namespace.
#	If allow_ui is True, animation commands are allowed from the script.
#	This function must be a generator.
# - compute(self, wake, expr, as_str):
#	Run code in the game's namespace and return a value.
#	The value is a str if as_str is True, a bool otherwise.
#	This function must be a generator.

class Lua: # Run Lua code. {{{
	'''This class handles the userspace lua environment.
	It uses the lua library, which is safe for running untrusted code.
	'''
	def __init__(self):
		self.lua = lua.Lua()
	def set(self, key, value):
		self.lua.run(var = key, value = value)
	def run(self, script, allow_ui = True):
		self.lua.run(script)
	def compute(self, expr, as_str):
		#print('computing: ', expr)
		ret = self.lua.run('return ' + expr)
		if as_str:
			return str(ret)
		else:
			return bool(ret)
# }}}

import lua

def Environment():
	return Lua()
# }}}

class Content_Connection: # {{{ Class for handling content management.
	def __init__(self, my_id, my_name, my_userdata, my_remote, managed_name): # {{{
		self.id = my_id
		self.name = my_name
		self.userdata = my_userdata
		self.remote = my_remote
		self.managed_name = managed_name
	def _init(self, wake):
		# TODO: Check that this user is allowed to edit content.
		# Other than that, nothing to do here.
		return
		yield	# Make sure this is a generator.
	# }}}
	def get_post_token(self):
		# TODO? use this token in a post request to upload files that way.
		pass
	# Groups {{{
	def list_groups(self):
		wake = (yield)
		data = (yield from serverdata.select('group', ('id', 'name'), wake = wake))
		return {d[0]: {'name': d[1]} for d in data}
	def add_group(self, name):
		wake = (yield)
		yield from serverdata.insert('group', {'name': name}, wake = wake)
	def update_group(self, groupid, name):
		wake = (yield)
		yield from serverdata.update('group', {'name': name}, ('=', 'id', groupid), wake = wake)
	def remove_group(self, groupid):
		wake = (yield)
		yield from serverdata.delete('group', ('=', 'id', groupid), wake = wake)
	# }}}
	# Chapters {{{
	def list_chapters(self):
		wake = (yield)
		data = (yield from serverdata.select('chapter', ('id', 'name'), wake = wake))
		return {d[0]: {'name': d[1]} for d in data}
	def add_chapter(self, name):
		wake = (yield)
		yield from serverdata.insert('chapter', {'name': name}, wake = wake)
	def update_chapter(self, chapterid, name):
		wake = (yield)
		yield from serverdata.update('chapter', {'name': name}, ('=', 'id', chapterid), wake = wake)
	def remove_chapter(self, chapterid):
		wake = (yield)
		yield from serverdata.delete('chapter', ('=', 'id', chapterid), wake = wake)
	# }}}
	# Access {{{
	def list_access(self):
		wake = (yield)
		return (yield from serverdata.select('access', ('groupid', 'chapter'), wake = wake))
	def add_access(self, groupid, chapterid):
		wake = (yield)
		present = (yield from serverdata.select('access', ('groupid',), ('and', ('=', 'groupid', groupid), ('=', 'chapter', chapterid)), wake = wake))
		assert len(present) == 0
		yield from serverdata.insert('access', {'groupid': groupid, 'chapter': chapterid}, wake = wake)
	def remove_access(self, groupid, chapterid):
		wake = (yield)
		yield from serverdata.delete('access', ('and', ('=', 'groupid', groupid), ('=', 'chapter', chapterid)), wake = wake)
	# }}}
	# Scripts {{{
	def list_scripts(self):
		wake = (yield)
		data = (yield from serverdata.select('script', ('id', 'name', 'chapter'), wake = wake))
		return {d[0]: {'name': d[1], 'chapter': d[2]} for d in data}
	def get_script(self, scriptid):
		wake = (yield)
		data = (yield from serverdata.select('script', ('script',), ('=', 'id', scriptid), wake = wake))
		return None if len(data) == 0 else data[0][0]
	def add_script(self, name, chapter, script):
		wake = (yield)
		yield from serverdata.insert('script', {'name': name, 'chapter': chapter, 'script': script}, wake = wake)
	def update_script(self, scriptid, name, chapter, script):
		wake = (yield)
		if script is None:
			yield from serverdata.update('script', {'name': name, 'chapter': chapter}, ('=', 'id', scriptid), wake = wake)
		else:
			yield from serverdata.update('script', {'name': name, 'chapter': chapter, 'script': script}, ('=', 'id', scriptid), wake = wake)
	def remove_script(self, scriptid):
		wake = (yield)
		yield from serverdata.delete('script', ('=', 'id', scriptid), wake = wake)
	# }}}
	# Questions {{{
	def list_questions(self):
		wake = (yield)
		data = (yield from serverdata.select('question', ('id', 'script', 'type', 'description'), wake = wake))
		return {('%d:%s' % (d[1], d[0])): {'type': d[2], 'description': d[3]} for d in data}
	def add_question(self, questionid, scriptid, type, description):
		wake = (yield)
		yield from serverdata.insert('question', {'id': questionid, 'script': scriptid, 'type': type, 'description': description}, wake = wake)
	def update_question(self, questionid, scriptid, type, description):
		wake = (yield)
		yield from serverdata.update('question', {'type': type, 'description': description}, ('and', ('=', 'id', questionid), ('=', 'script', scriptid)), wake = wake)
	def remove_question(self, questionid, scriptid):
		wake = (yield)
		yield from serverdata.delete('question', ('and', ('=', 'id', questionid), ('=', 'script', scriptid)), wake = wake)
	# }}}
	# Sprite ids {{{
	def list_spriteids(self):
		wake = (yield)
		data = (yield from serverdata.select('spriteid', ('name', 'chapter', 'id'), wake = wake))
		return {d[2]: {'name': d[0], 'chapter': d[1]} for d in data}
	def add_spriteid(self, name, chapter, spriteid):
		wake = (yield)
		yield from serverdata.insert('spriteid', {'name': name, 'chapter': chapter, 'id': spriteid}, wake = wake)
	def update_spriteid(self, spriteid, name, chapter):
		wake = (yield)
		yield from serverdata.update('spriteid', {'name': name, 'chapter': chapter}, ('=', 'id', spriteid), wake = wake)
	def remove_spriteid(self, spriteid):
		wake = (yield)
		yield from serverdata.delete('spriteid', ('=', 'id', spriteid), wake = wake)
	# }}}
	# Sprite images {{{
	def list_spriteimages(self):
		wake = (yield)
		data = (yield from serverdata.select('spriteimage', ('id', 'spriteid', 'mood', 'image'), wake = wake))
		return {d[0]: {'spriteid': d[1], 'mood': d[2], 'image': d[3]} for d in data}
	def add_spriteimage(self, spriteid, mood, image):
		wake = (yield)
		yield from serverdata.insert('spriteimage', {'spriteid': spriteid, 'mood': mood, 'image': image}, wake = wake)
	def update_spriteimage(self, spriteimageid, spriteid, mood, image):
		wake = (yield)
		yield from serverdata.update('spriteimage', {'spriteid': spriteid, 'mood': mood, 'image': image}, ('=', 'id', spriteimageid), wake = wake)
	def remove_spriteimage(self, spriteimageid):
		wake = (yield)
		yield from serverdata.delete('spriteimage', ('=', 'id', spriteimageid), wake = wake)
	# }}}
	# Images {{{
	def list_images(self):
		wake = (yield)
		data = (yield from serverdata.select('image', ('id', 'name', 'width', 'height', 'hotx', 'hoty'), wake = wake))
		return {d[0]: {'name': d[1], 'size': (d[2], d[3]), 'hotspot': (d[4], d[5])} for d in data}
	def get_image(self, imageid):
		wake = (yield)
		data = (yield from serverdata.select('image', ('url', 'width', 'height', 'hotx', 'hoty'), ('=', 'id', imageid), wake = wake))
		return None if len(data) == 0 else {'url': data[0][0], 'size': [data[0][1], data[0][2]], 'hotspot': [data[0][3], data[0][4]]}
	def add_image(self, imageid, name, url, size, hotspot):
		wake = (yield)
		# TODO: load image and detect size.
		yield from serverdata.insert('image', {'id': imageid, 'name': name, 'url': url, 'width': size[0], 'height': size[1], 'hotx': hotspot[0], 'hoty': hotspot[1]}, wake = wake)
	def update_image(self, imageid, name, url, size, hotspot):
		wake = (yield)
		# TODO: load image and detect size.
		if url is None:
			yield from serverdata.update('image', {'name': name, 'width': size[0], 'height': size[1], 'hotx': hotspot[0], 'hoty': hotspot[1]}, ('=', 'id', imageid), wake = wake)
		else:
			yield from serverdata.update('image', {'name': name, 'url': url, 'width': size[0], 'height': size[1], 'hotx': hotspot[0], 'hoty': hotspot[1]}, ('=', 'id', imageid), wake = wake)
	def remove_image(self, imageid):
		wake = (yield)
		yield from serverdata.delete('image', ('=', 'id', imageid), wake = wake)
	# }}}
	# Audio {{{
	def list_audio(self):
		wake = (yield)
		data = (yield from serverdata.select('audio', ('id', 'duration'), wake = wake))
		return {d[0]: {'duration': d[1]} for d in data}
	def get_audio(self, audioid):
		wake = (yield)
		data = (yield from serverdata.select('audio', ('url',), ('=', 'id', audioid), wake = wake))
		return None if len(data) == 0 else data[0][0]
	def add_audio(self, audioid, url, duration):
		wake = (yield)
		# TODO: load sound and detect duration.
		yield from serverdata.insert('audio', {'id': audioid, 'url': url, 'duration': duration}, wake = wake)
	def update_audio(self, audioid, url, duration):
		wake = (yield)
		# TODO: load sound and detect duration.
		if url is None:
			yield from serverdata.update('audio', {'duration': duration}, ('=', 'id', audioid), wake = wake)
		else:
			yield from serverdata.update('audio', {'url': url, 'duration': duration}, ('=', 'id', audioid), wake = wake)
	def remove_audio(self, audioid):
		wake = (yield)
		yield from serverdata.delete('audio', ('=', 'id', audioid), wake = wake)
	# }}}

def post(connection): # {{{ TODO Use this to send new content, or update it.
	'''Upload a new file for the sandbox.
	Credentials must be provided in the cookie. User must be allowed to use the sandbox.
	''' # FIXME: cookies are removed.
	if connection.busy:
		log('attempt to post sandbox while busy')
		return
	if 'cookie' not in connection.headers or 'file' not in connection.post[1]:
		debug(1, 'ignoring invalid POST request')
		sandboxserver.reply(connection, 404, 'invalid POST request', 'text/plain;charset=utf-8')
		return False
	c = connection.headers['cookie']
	kv = [chunk.strip().split('=', 1) for chunk in c.split(';')]
	kv = {x[0]: x[1] for x in kv}
	if 'name' not in kv or 'group' not in kv or 'key' not in kv or (kv['name'], kv['group']) not in users or users[(kv['name'], kv['group'])]['cookie'] != kv['key']:
		debug(1, 'invalid cookie for POST')
		sandboxserver.reply(connection, 403, b'invalid cookie for POST request', 'text/plain;charset=utf-8')
		return False
	u = users[(kv['name'], kv['group'])]
	if not u['sandbox']:
		debug(1, 'User is not allowed to use sandbox')
		sandboxserver.reply(connection, 403, b'User is not allowed to use sandbox', 'text/plain;charset=utf-8')
		return False
	# Credentials are good, save the files.
	basedir = os.path.join(config['data'], 'html', 'sandbox', config['sandbox'], kv['group'].lower(), kv['name'].lower())
	for f in connection.post[1]['file']:
		basename = os.path.basename(f[1]).split('.')
		if len(basename) > 1:
			basename[-2:] = [basename[-2] + '.' + basename[-1]]
		filename = os.path.join(basedir, *basename)
		os.makedirs(os.path.join(basedir, *basename[:-1]), exist_ok = True)
		# Copy the file.
		try:
			with open(filename, 'wb') as w:
				with open(f[0], 'rb') as r:
					w.write(r.read())
			debug(1, 'copied {} to {}'.format(f[0], filename))
		except:
			debug(1, 'unable to copy file')
			traceback.print_exc()
	sandboxserver.page(connection)
	return False
# }}}
# }}}

class Connection: # {{{
	# Internals. {{{
	def __init__(self, my_id, my_name, my_userdata, my_remote, managed_name): # {{{
		self.id = my_id
		self.name = my_name
		self.userdata = my_userdata
		self.remote = my_remote
		self.manged_name = managed_name
		self.display_name = my_name + (' (%s)' % managed_name if managed_name is not None else '')
		self.new_commands = None	# This is initialized to a list when running code and filled with new commands by it.
	# }}}
	def _init(self, wake): # {{{
		# Delayed contructor. Must be a generator.
		self.closed = refresh_admins
		self.busy = False
		debug(2, 'New connection from {}:{}'.format(*self.remote.socket.remote))
		u = {}
		users[self.id] = u
		u['connection'] = self
		self.user = u
		data = (yield from self.userdata.select('id', ('my_name', 'my_group'), wake = wake))
		if len(data) == 0:
			groupname = (yield from serverdata.select('group', ('name',), ('=', 'id', 1), wake = wake))
			assert len(groupname) == 1
			yield from self.userdata.insert('id', {'my_name': self.name, 'my_group': groupname[0][0]}, wake = wake) 
			my_group = 1
		else:
			self.name = data[0][0]
			g = (yield from serverdata.select('group', ('id',), ('=', 'name', data[0][1]), wake = wake))
			if len(g) != 1:
				my_group = 1
			else:
				my_group = g[0][0]
		debug(1, 'User {}:{} logged in from {}:{}'.format(self.name, my_group, *self.remote.socket.remote))
		u['name'] = self.name
		u['group'] = my_group
		u['program'] = []
		u['run_stack'] = []
		u['chapter'] = None	# Current chapter.
		u['question'] = None	# Question that is currently being asked.
		scripts = (yield from content.list(wake, my_group))
		u['chapterprefix'] = []
		if len(scripts) > 0:
			while len(scripts[0]) > 1 and all(x[0] == scripts[0][0] for x in scripts):
				u['chapterprefix'].append(scripts[0][0])
				for s in scripts:
					s.pop(0)
		self.remote.contents.event(scripts)
		self.remote.main.event(self.display_name)
		refresh_admins()
	# }}}
	def _finish_login(self, wake = None): # {{{
		# TODO: This function is never called anymore. It should be called when (managed?) players reconnect.
		if wake is None:
			wake = (yield)
		if self.user['chapter'] is not None:
			if len(self.user['run_stack']) > 0 and len(self.user['run_stack'][-1]['program']) > 1:
				setup = []
				state = self.user['_kinetic_state']
				if state['background'] is not None:
					setup.append({'action': 'scene', 'target': state['background'], 'args': {'with': None}})
				for spr in state['sprite']:
					s = state['sprite'][spr]
					setup.append({'action': 'show', 'target': spr, 'image': s['image'], 'args': {'from': s['from'], 'to': s['to'], 'scale': s['scale'], 'rotation': s['rotation'], 'with': None, 'around': None, 'in': None}})
				self.remote.kinetic.event(setup, state['music'])
				if not (yield from self._run_item(wake, self.user['run_stack'][-1]['program'][self.user['run_stack'][-1]['current']])):
					debug(0, 'Bug: saved state of user {}:{} was not a waiting state'.format(name, group))
					yield from self._run(wake)
	# }}}
	def _safe_eval(self, expr, as_str): # {{{
		'Evaluate an expression through Lua.'
		ret = self.user['environment'].compute(expr, as_str)
		return str(ret) if as_str else ret
	# }}}
	def _parse_text(self, text): # {{{
		'Do substitutions on a text that is going to be shown to the user. This should be called with "yield from".'
		if text is None:
			return None
		result = ''
		for m in re.finditer('\${(.*?)}|[^$]+', text):
			if m.group(1) is None:
				# This is not a substitution; add the string to the result.
				result += m.group(0)
			else:
				# This is a substitution; add the evaluated string to the result.
				result += self._safe_eval(m.group(1), as_str = True)
		return result
	# }}}
	def _parse_time(self, wake, t): # {{{
		'Parse a string (possibly including substitutions) as a time. Units of s for seconds or ms for milliseconds are required. This should be called with "yield from".'
		i = self._parse_text(t).strip()
		r = re.match(r'([-+.e0-9]+)\s*(m?)s$', i)
		if r is None:
			return None
		else:
			try:
				num = float(r.group(1))
				if r.group(2) == 'm':
					num /= 1e3
				return num
			except ValueError:
				debug(0, 'error parsing time {}'.format(i))
				return None
	# }}}
	def _answer(self, wake, style): # {{{
		'''Set style for last answer. This should be called with "yield from".'''
		if self.user['question'] is None:
			debug(1, 'answer style given before a question was answered')
			return
		style = self._parse_text(style)
		yield from self.userdata.update('answer', {'style': style}, ('and', ('=', 'question', self.user['question']), ('=', 'script', self.user['scripttag'])), wake = wake)
		refresh_admins()
	# }}}
	def _home(self): # {{{
		self.user['chapter'] = None
		del self.user['environment']
		refresh_admins()
		self.remote.main.event(self.display_name)
	# }}}
	def _clear_pending(self): # {{{
		# update kinetic state.
		def handle_action(action, state):
			if action['action'] in ('speech', 'sound', 'wait'):
				# Nothing to update.
				pass
			elif action['action'] == 'scene':
				state['background'] = action['target']
			elif action['action'] == 'music':
				state['music'] = action['target']
			elif action['action'] in ('serial', 'parallel'):
				for a in action['actions']:
					handle_action(a, state)
			elif action['action'] == 'hide':
				del state['sprite'][action['target']]
			else:
				assert action['action'] in ('show', 'move')

				# If target sprite does not exist, create it (with no image).
				if action['target'] not in state['sprite']:
					state['sprite'][action['target']] = {'from': [(0, 0), (0, 0), None], 'to': [(0, 0), (0, 0), None], 'scale': None, 'rotation': None, 'image': None}
				# Store target sprite in local variable.
				target = state['sprite'][action['target']]

				# Set mood image.
				target['target'] = action['target']
				target['mood'] = action['mood']
				args = action['args']
				for prop in ('from', 'to', 'scale', 'rotation'):
					if args[prop] is not None:
						target[prop] = args[prop]
		for action in self.user['_pending']:
			handle_action(action, self.user['_kinetic_state'])
		#debug(0, repr(self.user['_pending']))
		self.user['_pending'] = []
	# }}}
	def _start(self, wake, script_content, send_errors): # {{{
		self.user['program'], errors = script_content
		if send_errors:
			if len(errors) > 0:
				errors = markdown('# Errors:\n' + '\n\n'.join(errors))
			else:
				errors = ''
			self.remote.error.event(errors)
		self.user['run_stack'] = [{'program': self.user['program'], 'current': 0}]
		# Sprites are stored in two steps.
		# All available sprites are loaded into user['sprite'] by this function.
		# All active sprites (declared with a "sprite" command, may or may not be onscreen are in user['activesprite']. Both are dicts.
		# user['sprite'] has sprite names (as defined in db) as keys. Its values are dicts with mood names as keys and their numerical image ids as values.
		# user['activesprite'] has tags as used in the script as keys. Its values are dicts with items:
		#   'name': The character's name that is shown on screen as the speaker name,
		#   'id': The db sprite name, which is used as the key in user['sprite'] and
		#   'mood': The currently active mood, for when there is speech without an explicit mood.
		self.user['sprite'] = {}
		self.user['activesprite'] = {}
		self.user['_pending'] = []
		self.user['question'] = None
		# Set up self.user['sprite']. {{{
		global_sprites = (yield from serverdata.select('spriteid', ('id', 'name'), ('=', 'chapter', None), wake = wake))
		local_sprites = (yield from serverdata.select('spriteid', ('id', 'name'), ('=', 'chapter', self.user['chapter']), wake = wake))
		spriteid = {name: id for id, name in global_sprites}
		spriteid.update({name: id for id, name in local_sprites})
		for name in spriteid:
			id = spriteid[name]
			moods = (yield from serverdata.select('spriteimage', ('mood', 'image'), ('=', 'spriteid', id), wake = wake))
			self.user['sprite'][name] = {m[0]: m[1] for m in moods}
		sprites = {name: list(self.user['sprite'][name].keys()) for name in spriteid}
		# }}}
		self.user['environment'] = Environment()
		self.user['environment'].set('name', self.user['name'])
		self.user['environment'].set('group', self.user['group'])
		self.user['environment'].set('chapter', self.user['chapter'])
		self.user['environment'].set('script', self.user['script'])
		self.user['environment'].set('sprites', sprites);	# Available sprites (and moods).
		self.user['environment'].set('sprite', self.user['activesprite']);	# Active sprites.
		startup = fhs.read_data(os.path.join('include', 'startup.lua'))
		if startup is not None:
			try:
				self.user['environment'].run(startup.read(), False)
			except:
				debug(1, 'Error in startup script')
				traceback.print_exc()
		yield from self._run(wake)
	# }}}
	def _question(self, qtype, last_answer, markdown, options): # {{{
		if qtype == 'unit':
			qtype = 'short'
		if qtype == 'longunit':
			qtype = 'longshort'
		qtext = self._parse_text(markdown)
		parsed_options = []
		if options is not None:
			for x in options:
				parsed_options.append(self._parse_text(x))
		self.remote.question.event(self.user['_pending'], qtext, qtype, parsed_options, last_answer)
		self.breaking = True
		return True
	# }}}
	def _add_character(self, code, name, imgs, ext): # {{{
		self.user['characters'][code] = {'name': name, 'imgs': imgs, 'ext': ext, 'mood': 'default', 'x': 0, 'y': 0}
		c = self.user['characters'][code]
	# }}}
	def _show(self, tag, mood = None, at = 'center', transition = None, timing = None): # {{{
		yield from self._run_item(wake, ['story', None, content.showhide(True, tag, mood, at, transition, timing, False, None)])
	# }}}
	def _hide(self, tag, at = 'center', transition = None, timing = None): # {{{
		yield from self._run_item(wake, ['story', None, content.showhide(False, tag, None, at, transition, timing, False, None)])
	# }}}
	def _run(self, wake): # {{{
		watchdog = 0
		while len(self.user['run_stack']) > 0:
			watchdog += 1
			if watchdog > 1000:
				debug(1, 'hanging script detected: {}; killing it'.format(self.user['chapter']))
				self.remote.error.event(['Script stopped working and was killed.'])
				self.user['run_stack'] = [{'program': self.user['program'], 'current': len(self.user['program'])}]
				refresh_admins()
				return
			# Pop off stack levels until there's an instruction.
			while len(self.user['run_stack'][-1]['program']) <= self.user['run_stack'][-1]['current']:
				self.user['run_stack'].pop()
				#print('pop', self.user['run_stack'])
				if len(self.user['run_stack']) == 0:
					# Send final "question".
					self.remote.question.event(self.user['_pending'], '', 'choice', ['Done'])
					self.breaking = True
					refresh_admins()
					return
			# Run instructions.
			if (yield from self._run_item(wake, self.user['run_stack'][-1]['program'][self.user['run_stack'][-1]['current']])):
				#print('break')
				break
			#print('no break')
		refresh_admins()
	# }}}
	def _run_item(self, wake, code): # {{{
		debug(3, '{}:{} running item {}'.format(self.user['name'], self.user['group'], repr(code)))
		if code['command'] == 'label': # {{{
			pass
		# }}}
		elif code['command'] == 'answer': # {{{
			yield from self._answer(wake, code['answer'])
		# }}}
		elif code['command'] == 'if': # {{{
			self.user['run_stack'][-1]['current'] += 1
			for expr, target in code['code']:
				if expr is None or self._safe_eval(expr, as_str = False):
					self.user['run_stack'].append({'program': target, 'current': 0})
					break
			return False
		# }}}
		elif code['command'] == 'while': # {{{
			# Don't increment instruction pointer, so the loop restarts.
			if self._safe_eval(code['test'], as_str = False):
				self.user['run_stack'].append({'program': code['code'], 'current': 0})
			else:
				# exit the while loop.
				self.user['run_stack'][-1]['current'] += 1
				# handle else clause, if present.
				if code['else'] is not None:
					self.user['run_stack'].append({'program': code['else'], 'current': 0})
			return False
		# }}}
		elif code['command'] in ('continue', 'break'): # {{{
			while self.user['run_stack'][-1]['current'] >= len(self.user['run_stack'][-1]['program']) or self.user['run_stack'][-1]['program'][self.user['run_stack'][-1]['current']]['command'] != 'while':
				self.user['run_stack'].pop()
			if code['command'] == 'break':
				self.user['run_stack'][-1]['current'] += 1
			return False
		# }}}
		elif code['command'] == 'goto': # {{{
			# Break to top level and jump to requested label.
			while len(self.user['run_stack']) > 1:
				self.user['run_stack'].pop()
			self.user['run_stack'][-1]['current'] = code['target']
			return False
		# }}}
		elif code['command'] == 'code': # {{{
			self.breaking = False
			self.user['run_stack'][-1]['current'] += 1	# Do this before running the code, so goto works.
			try:
				self.new_commands = []
				self.user['environment'].run(code['code'])
				if len(self.new_commands) > 0:
					self.user['run_stack'].append({'program': self.new_commands, 'current': 0})
			except:
				debug(0, 'Error in script: {}'.format(code['code']))
				traceback.print_exc()
				self.remote.error.event(code['code'])
			finally:
				self.new_commands = None
			return self.breaking
		# }}}
		elif code['command'] == 'video': # {{{
			self.remote.video.event(self.user['_pending'], code['video'])
			return True
		# }}}
		elif code['command'] == 'sprite': # {{{
			self.user['activesprite'][code['tag']] = {'name': self._parse_text(code['name']), 'id': self._parse_text(code['images']), 'mood': ''}
		# }}}
		elif code['command'] == 'kinetic': # {{{
			def build_kinetic(wake, item): # {{{
				if item['action'] == 'speech': # {{{
					target = item['speaker']
					#print('check', item, self.user['activesprite'])
					speaker = None if target is None else self.user['activesprite'][target]['name'] if target in self.user['activesprite'] else '(' + target + ')'
					if target in self.user['activesprite']:
						spriteid = self.user['activesprite'][target]['id']
						if spriteid in self.user['sprite']:
							sprite = self.user['sprite'][spriteid]
							if item['image'] not in sprite:
								if item['image'] is not None:
									debug(0, 'ignoring invalid image %s for %s' % (item['image'], target))
									if 'side' in self.user['activesprite'][target]:
										image = self.user['activesprite'][target]['side']
									else:
										image = None
								else:
									image = None
							else:
								image = item['image']
						else:
							image = None
					else:
						image = None
					return {'action': 'speech', 'speaker': speaker, 'target': target, 'image': image, 'text': markdown(self._parse_text(item['markdown']))}
				# }}}
				if item['action'] == 'wait': # {{{
					return {'action': 'wait', 'time': self._parse_time(wake, item['time'])}
				# }}}
				if item['action'] in ('sound', 'music'): # {{{
					target = None if item['target'] is None else self._parse_text(item['target'])
					return {'action': item['action'], 'target': target}
				# }}}
				if item['action'] in ('serial', 'parallel'): # {{{
					actions = []
					for x in item['actions']:
						actions.append((yield from build_kinetic(wake, x)))
					return {'action': item['action'], 'args': item['args'], 'actions': actions}
				# }}}
				args = {}
				# Parse animation arguments. {{{
				def parse_location(loc): # {{{
					if loc is None:
						return None
					l = [x.strip() for x in self._parse_text(loc).split()]
					if l[0] == 'outleft':
						l[0] = (1, -1)
					elif l[0] == 'inleft':
						l[0] = (-1, -1)
					elif l[0] == 'outright':
						l[0] = (-1, 1)
					elif l[0] == 'inright':
						l[0] = (1, 1)
					elif l[0] == 'left':
						l[0] = (0, -.4)
					elif l[0] == 'center':
						l[0] = (0, 0)
					elif l[0] == 'right':
						l[0] = (0, .4)
					else:
						try:
							l[0] = (0, float(l[0]))
						except:
							l[0] = (0, 0)
					if len(l) == 1:
						l.append((0, 0))
					elif l[1] == 'outbottom':
						l[1] = (1, 0)
					elif l[1] == 'inbottom':
						l[1] = (-1, 0)
					elif l[1] == 'outtop':
						l[1] = (-1, 1)
					elif l[1] == 'intop':
						l[1] = (1, 1)
					elif l[1] == 'bottom':
						l[1] = (0, 0)
					elif l[1] == 'low':
						l[1] = (0, .2)
					elif l[1] == 'middle':
						l[1] = (0, .5)
					elif l[1] == 'high':
						l[1] = (0, .8)
					elif l[1] == 'top':
						l[1] = (0, 1)
					else:
						try:
							l[1] = (0, float(l[1]))
						except:
							l[1] = (0, 0)
					if len(l) == 2:
						l.append(None)
					else:
						try:
							l[2] = int(l[2])
						except:
							l[2] = None
					return l
				# }}}
				def parse_around(loc): # {{{
					if loc is None:
						return None
					l = [x.strip() for x in self._parse_text(loc).split()]
					if l[-1] in ('cw', 'ccw'):
						cw = l[-1] == 'cw'
						l.pop()
					else:
						cw = False
					if l[0] == 'left':
						l[0] = -.4
					elif l[0] == 'center':
						l[0] = 0
					elif l[0] == 'right':
						l[0] = .4
					else:
						try:
							l[0] = float(l[0])
						except:
							l[0] = 0
					if len(l) == 1:
						l.append(0)
					elif l[1] == 'bottom':
						l[1] = 0
					elif l[1] == 'low':
						l[1] = .2
					elif l[1] == 'middle':
						l[1] = .5
					elif l[1] == 'high':
						l[1] = .8
					elif l[1] == 'top':
						l[1] = 1
					else:
						try:
							l[1] = float(l[1])
						except:
							l[1] = 0
					return l[:2] + [cw]
				# }}}
				if item['args']['in'] is None: # {{{
					args['in'] = None
				else:
					args['in'] = self._parse_time(wake, item['args']['in'])
				# }}}
				if args['in'] is None:
					args['with'] = 'jump'
				elif item['args']['with'] is None: # {{{
					args['with'] = 'move'
				else:
					w = self._parse_text(item['args']['with'])
					if w not in ('jump', 'dissolve', 'move'):
						debug(0, 'invalid transition {}'.format(w))
						args['with'] = None
					else:
						args['with'] = w
				# }}}
				args['to'] = parse_location(item['args']['to'])
				args['from'] = parse_location(item['args']['from'])
				args['around'] = parse_around(item['args']['around'])
				if item['args']['scale'] is None: # {{{
					args['scale'] = None
				else:
					s = [x.strip() for x in self._parse_text(item['args']['scale']).split()]
					try:
						s = [float(x) for x in s]
						if len(s) == 1:
							s.append(s[0])
						elif len(s) > 2:
							s = [s[0], s[1]]
					except:
						debug(0, 'error parsing scale {}'.format(s))
						s = None
					args['scale'] = s
				# }}}
				if item['args']['rotation'] is None: # {{{
					args['rotation'] = None
				else:
					r = self._parse_text(item['args']['rotation']).strip()
					if r.endswith('°'):
						f = 360
						r = r[:-1]
					else:
						f = 1
					try:
						r = float(r) / f
					except:
						debug(0, 'error parsing rotation {}'.format(r))
						r = None
					args['rotation'] = r
				# }}}
				if item['target'] is None: # {{{
					target = None
					mood = None
				else:
					target = self._parse_text(item['target'])
					if item['action'] != 'scene':
						mood = self._parse_text(item['mood'] or '')
					else:
						mood = None
				# }}}
				# }}}
				#print('returning build', item['action'])
				return {'action': item['action'], 'target': target, 'mood': mood, 'args': args}
			# }}}
			actions = []
			for x in code['kinetic']:
				#print('building', x)
				actions.append((yield from build_kinetic(wake, x)))
			self.user['_pending'].extend(actions)
			#print('now pending:', self.user['_pending'])
		# }}}
		elif code['command'] == 'question': # {{{
			if code['type'] == 'hidden':
				self._store_answer(code['variable'], self._safe_eval(code['markdown'], as_str = True))
			else:
				# Question.
				answers = (yield from self.userdata.select('answer', ('answer',), ('and', ('=', 'script', self.user['scripttag']), ('=', 'question', code['variable'])), wake = wake))
				if len(answers) == 0:
					last_answer = None
				else:
					last_answer = json.loads(answers[-1][0])
				#print('sending question', code['type'])
				return self._question(code['type'], last_answer, code['markdown'], code['option'])
		else:
			debug(0, 'invalid command {}'.format(code))
		# }}}
		self.user['run_stack'][-1]['current'] += 1
		return False
	# }}}
	def _update_sprite(self, tag, data): # {{{
		for item in ('x', 'y', 'mood'):
			if item in data:
				self.user['characters'][tag][item] = data[item]
		c = self.user['characters'][tag]
		data['url'] = c['imgs'] + (data.pop('mood') if 'mood' in data else 'default') + c['ext']
	# }}}
	def _store_answer(self, question, answer, store = True): # {{{
		self.user['environment'].set(question, answer)
		if store:
			self.userdata.insert('answer', {'script': self.user['scripttag'], 'question': question, 'answer': json.dumps(answer)})
			self.user['question'] = question
		else:
			self.user['question'] = None
	# }}}
	# }}}
	def get_sprite_image(self, sprite_tag, sprite_mood): # {{{
		'Retrieve image from database. Return data url.'
		wake = (yield)
		#print('getting image for sprite', repr(sprite_tag), repr(sprite_mood))
		if sprite_tag in self.user['activesprite']:
			sprite_name = self.user['activesprite'][sprite_tag]['id']
		else:
			sprite_name = sprite_tag
		if sprite_name in self.user['sprite']:
			if sprite_mood in self.user['sprite'][sprite_name]:
				imageid = self.user['sprite'][sprite_name][sprite_mood]
			else:
				imageid = self.user['sprite'][sprite_name]['']
		else:
			s = self.user['sprite']['']
			if sprite_mood in s:
				imageid = s[sprite_mood]
			else:
				imageid = s['']
		data = (yield from serverdata.select('image', ('url', 'width', 'height', 'hotx', 'hoty'), ('=', 'id', imageid), wake = wake))
		assert len(data) == 1
		#print('image id', imageid, 'from', repr(self.user['sprite']), 'data', data[0][0][:30])
		return {'url': data[0][0], 'size': (data[0][1], data[0][2]), 'hotspot': (data[0][3], data[0][4])}
	# }}}
	def home(self): # {{{
		if self.busy and not force:
			traceback.print_stack()
			log('attempt to home while busy')
			return
		self._home()
	# }}}
	def start(self, script): # {{{
		wake = (yield)
		if self.busy:
			log('attempt to start while busy')
			traceback.print_stack()
			return
		self.user['_kinetic_state'] = {'background': None, 'sprite': {}, 'music': None}
		self.busy = True
		chapterid, scriptid, code = (yield from content.get(wake, self.user['group'], self.user['chapterprefix'] + script))
		self.user['scripttag'] = '\t'.join(script)
		self.user['chapter'] = chapterid
		self.user['script'] = scriptid
		try:
			yield from self._start(wake, code, False)
		finally:
			self.busy = False
	# }}}
	def answer(self, answer): # {{{
		wake = (yield)
		if self.busy:
			log('attempt to answer while busy')
			return
		self._clear_pending()
		debug(3, '{}:{} answers {}'.format(self.user['name'], self.user['group'], answer))
		if len(self.user['run_stack']) == 0:
			# Ignore answer for final "Done" button.
			self._home()
			return
		if self.user['run_stack'][-1]['current'] >= len(self.user['run_stack'][-1]['program']):
			self.busy = True
			try:
				yield from self._run(wake)
			finally:
				self.busy = False
			return
		current = self.user['run_stack'][-1]['program'][self.user['run_stack'][-1]['current']]
		if current['type'] not in ('short', 'long', 'choice', 'unit', 'longshort', 'longunit', 'longchoice'):
			debug(1, 'answer given by {}:{} for non-question: {}'.format(self.remote.socket.remote[0], self.remote.socket.remote[1], current))
			return
		store = not current['variable'].startswith('_')
		def parse_unit(src):
			r = re.match(r'\s*(?:(\S+)\s*=\s*)?([+-]?[0-9]*(?:[.,]\d*)?)(?:·10([⁻⁺]?[⁰¹²³⁴⁵⁶⁷⁸⁹]+))?\s*(\S*)\s*$', src)
			# groups:
			# 1: quantity	(\S+)
			# 2: base value	([+-]?[0-9]*(?:[.,]\d*)?)
			# 3: exponent	(·10([⁻⁺]?[⁰¹²³⁴⁵⁶⁷⁸⁹]+))?
			# 4: unit	(\S*)
			if not r:
				debug(3, 'no match for unit answer')
				answer = {'quantity': None, 'unit': None, 'digits': None, 'value': None}
			try:
				answer = {}
				answer['quantity'] = r.group(1)
				base = r.group(2).replace(',', '.')
				exponent = None if r.group(3) is None else int(fromsuper(r.group(3)))
				answer['unit'] = r.group(4)
				answer['digits'] = len(base.replace('.', '').lstrip('0'))
				answer['value'] = float(base) * (1 if exponent is None else 10 ** exponent)
			except:
				traceback.print_exc()
				answer = {'quantity': None, 'unit': None, 'digits': None, 'value': None}
			debug(3, 'unit-split answer: {}'.format(answer))
			return answer
		raw = answer
		if current['type'] == 'choice':
			if isinstance(answer, int) and 1 <= answer <= len(current['option']):
				answer = {'index': answer, 'text': current['option'][answer - 1]}
			else:
				answer = {}
			if len(current['option']) <= 1:
				store = False
		elif current['type'] == 'longchoice':
			if isinstance(answer[0], int) and 1 <= answer[0] <= len(current['option']):
				answer = {'index': answer[0], 'text': current['option'][answer[0] - 1], 'long': str(answer[1]).strip()}
			else:
				# Leave answer string as is (but force str); this only happens when users are messing with the js.
				debug(2, 'unparsable longchoice answer: {}'.format(answer))
				answer = {'choice': None, 'long': str(answer).strip()}
		elif current['type'] == 'unit':
			answer = parse_unit(answer)
		elif current['type'] == 'longunit':
			l = answer[1]
			try:
				answer = parse_unit(answer[0])
				answer['long'] = l
			except:
				# Leave answer string as is (but force str); this only happens when users are messing with the js.
				debug(2, 'unparsable longunit answer: {}'.format(answer))
				answer = {}
		elif current['type'].startswith('long') and current['type'] != 'long':
			try:
				answer = {'text': str(answer[0]).strip(), 'long': str(answer[1]).strip()}
			except:
				# Leave answer string as is (but force str); this only happens when users are messing with the js.
				debug(2, 'unparsable long* answer: {}'.format(answer))
				answer = {}
		else:
			answer = {'text': answer}
		answer['raw'] = raw
		answer['style'] = []
		self._store_answer(current['variable'], answer, store)
		self.user['run_stack'][-1]['current'] += 1
		self.busy = True
		try:
			yield from self._run(wake)
		finally:
			self.busy = False
	# }}}
	def video_done(self): # {{{
		wake = (yield)
		if self.busy:
			log('attempt to finish video while busy')
			return
		self._clear_pending()
		if self.user['run_stack'][-1]['current'] >= len(self.user['run_stack'][-1]['program']):
			self.busy = True
			try:
				yield from self._run(wake)
			finally:
				self.busy = False
			return
		current = self.user['run_stack'][-1]['program'][self.user['run_stack'][-1]['current']]
		if current[0] == 'video':
			self.user['run_stack'][-1]['current'] += 1
			self.busy = True
			try:
				yield from self._run(wake)
			finally:
				self.busy = False
	# }}}
	def sandbox_list(self): # {{{
		if self.busy:
			log('attempt to list sandbox while busy')
			return
		if not self.user['sandbox']:
			debug(1, 'User {}:{} is not allowed to use sandbox'.format(self.user['name'], self.user['group']))
			raise PermissionError('User is not allowed to use sandbox')
		basedir = os.path.join(config['data'], 'html', 'sandbox', config['sandbox'], self.user['group'].lower(), self.user['name'].lower())
		if not os.path.exists(basedir):
			return []
		def make_list(base, current):
			ret = []
			for f in os.listdir(os.path.join(base, current)):
				filename = os.path.join(base, current, f)
				if os.path.isdir(filename):
					if f[0] == '.':
						continue
					ret.extend(make_list(base, os.path.join(current, f)))
				else:
					ret.append(os.path.join(current, f))
			return ret
		return make_list(basedir, '')
	# }}}
	def sandbox_remove(self, name): # {{{
		if self.busy:
			log('attempt to remove sandbox while busy')
			return
		if not self.user['sandbox']:
			debug(1, 'User is not allowed to use sandbox')
			raise PermissionError('User is not allowed to use sandbox')
		basedir = os.path.join(config['data'], 'html', 'sandbox', config['sandbox'], self.user['group'].lower(), self.user['name'].lower())
		d = os.path.dirname(name)
		assert '.' not in d and os.path.exists(os.path.join(basedir, name))
		os.unlink(os.path.join(basedir, name))
	# }}}
	def sandbox_play(self, scriptname): # {{{
		wake = (yield)
		if self.busy:
			log('attempt to play sandbox while busy')
			return
		if not self.user['sandbox']:
			debug(1, 'User is not allowed to use sandbox')
			raise PermissionError('User is not allowed to use sandbox')
		basedir = os.path.join(config['data'], 'html', 'sandbox', config['sandbox'], self.user['group'].lower(), self.user['name'].lower())
		d = os.path.dirname(scriptname)
		assert '.' not in d and os.path.exists(os.path.join(basedir, scriptname))
		self.user['chapter'] = ('sandbox', self.user['name'].lower())
		self.busy = True
		try:
			yield from self._start(wake, content.get_file(self.user['group'], self.user['chapter'], os.path.join(basedir, scriptname)), True)
		finally:
			self.busy = False
	# }}}
	def sandbox_get(self, name): # {{{
		if self.busy:
			log('attempt to get sandbox while busy')
			return
		if not self.user['sandbox']:
			debug(1, 'User is not allowed to use sandbox')
			raise PermissionError('User is not allowed to use sandbox')
		basedir = os.path.join(config['data'], 'html', 'sandbox', config['sandbox'], self.user['group'].lower(), self.user['name'].lower())
		d = os.path.dirname(name)
		assert '.' not in d and os.path.exists(os.path.join(basedir, name))
		return open(os.path.join(basedir, name)).read()
	# }}}
	def sandbox_put(self, name, contents): # {{{
		if self.busy:
			log('attempt to put sandbox while busy')
			return
		if not self.user['sandbox']:
			debug(1, 'User is not allowed to use sandbox')
			raise PermissionError('User is not allowed to use sandbox')
		basedir = os.path.join(config['data'], 'html', 'sandbox', config['sandbox'], self.user['group'].lower(), self.user['name'].lower())
		d = os.path.dirname(name)
		assert '.' not in d
		os.makedirs(basedir, exist_ok = True)
		open(os.path.join(basedir, name), 'w').write(contents)
	# }}}
# }}}

def connection_selector(my_id, my_name, my_userdata, my_remote, managed_name): # {{{
	parts = my_remote.data['url'].strip('/').split('/')
	# example parts: ['content', 'index.html', 'websocket']
	if len(parts) > 2:
		if parts[-3] == 'admin':
			return Admin_Connection(my_id, my_name, my_userdata, my_remote, managed_name)
		if parts[-3] == 'content':
			return Content_Connection(my_id, my_name, my_userdata, my_remote, managed_name)
	return Connection(my_id, my_name, my_userdata, my_remote, managed_name)
# }}}

db_config = { # {{{
	'group': [
		('id', 'int(11) NOT NULL AUTO_INCREMENT PRIMARY KEY'),
		('name', 'text NOT NULL')
	],
	'chapter': [
		('id', 'int(11) NOT NULL AUTO_INCREMENT PRIMARY KEY'),
		('name', 'text NOT NULL'),
		('parent', 'int(11) DEFAULT NULL'),
	],
	'access': [
		('groupid', 'int(11) NOT NULL'),
		('chapter', 'int(11) DEFAULT NULL'),
	],
	'script': [
		('id', 'int(11) NOT NULL AUTO_INCREMENT PRIMARY KEY'),
		('name', 'text NOT NULL'),
		('chapter', 'int(11) NOT NULL'),
		('script', 'longtext NOT NULL')
	],
	'question': [
		('id', 'text NOT NULL'),
		('script', 'int(11) NOT NULL'),
		('type', 'varchar(255) NOT NULL'),
		('description', 'varchar(255) NOT NULL')
	],
	'spriteid': [
		('name', 'text NOT NULL'),	# Sprite name.
		('chapter', 'int(11) DEFAULT NULL'),	# Chapter id, or NULL for global sprites.
		('id', 'int(11) NOT NULL AUTO_INCREMENT UNIQUE'),	# Sprite id.
	],
	'spriteimage': [
		('id', 'int(11) NOT NULL AUTO_INCREMENT PRIMARY KEY'),	# Sprite image id.
		('spriteid', 'int(11) NOT NULL'),	# Sprite id.
		('mood', 'text NOT NULL'),	# Mood name.
		('image', 'int(11) NOT NULL'),	# Image id.
	],
	'image': [
		('id', 'int(11) NOT NULL AUTO_INCREMENT PRIMARY KEY'),
		('name', 'varchar(255) NOT NULL'),
		('url', 'longtext NOT NULL'),	# Data url.

		# Size of image in screen units.
		('width', 'float NOT NULL'),
		('height', 'float NOT NULL'),

		# Location of hotspot in screen units.
		# The origin for the hotspot coordinates is the bottom left corner of the image.
		('hotx', 'float NOT NULL'),
		('hoty', 'float NOT NULL'),
	],
	'audio': [
		('id', 'varchar(255) NOT NULL PRIMARY KEY'),
		('url', 'longtext NOT NULL'),	# Data url.
		('duration', 'int(11) NOT NULL'),
	],
} # }}}
player_config = { # {{{
	'id': [	# This table has only one row.
		('my_name', 'varchar(255) NOT NULL'),
		('my_group', 'varchar(255) NOT NULL')
	],
	'answer': [
		('script', 'mediumtext NOT NULL'),	# tab-separated list of chapters.
		('question', 'text NOT NULL'),
		('answer', 'longblob NOT NULL'),
		('style', 'mediumtext DEFAULT NULL')
	]
} # }}}

# Main program {{{
server, serverdata = userdata.setup(connection_selector, config, db_config, player_config, httpdirs = ('html',), proxy = config['proxy'])
server.post = post
content.init(serverdata)

print('server is running on port {}'.format(config['port']))
websocketd.fgloop()
# }}}

# vim: set foldmethod=marker :
