#!/usr/bin/python3
# vim: set fileencoding=utf-8 :

# Imports and config. {{{
import sys
import os
import base64
import io
import math
import re
import zipfile
import traceback
import time
import random
import fhs
import websocketd
import json
import userdata
from userdata import _, N_
from markdown import markdown
from websocketd import log

fhs.option('port', 'network port to listen for players', default = '7000')
fhs.option('proxy', 'virtual proxy directory', default = 'supernovel')
fhs.option('logfile', 'file for logging events', default = '')
fhs.option('loglimit', 'maximum loglevel that is written to screen', default = 1)
config = userdata.fhs_init('http://localhost:8879', 'supernovel', help = 'Visual novel style tool for students to learn with teacher monitoring options', contact = 'Bas Wijnen <wijnen@debian.org>', version = '0.2')
from debug import debug
import content
# }}}

''' Log priorities: {{{
		0: Critical (system code errors)
		1: Important (user code errors)
		2: Normal (communication notifications)
		3: Debug
}}} '''

# Sub-/superscript helpers. {{{
tosuper_dict = {'0': '⁰', '1': '¹', '2': '²', '3': '³', '4': '⁴', '5': '⁵', '6': '⁶', '7': '⁷', '8': '⁸', '9': '⁹', '-': '⁻', '+': '⁺', '=': '⁼', '(': '⁽', ')': '⁾', 'n': 'ⁿ'}
def tosuper(src):
	return ''.join(tosuper_dict.get(c, c) for c in src)

fromsuper_dict = {v: k for k, v in tosuper_dict.items()}
def fromsuper(src):
	return ''.join(fromsuper_dict.get(c, c) for c in src)
# }}}

# List of all currently logged in users.
users = {}
admins = {}
disconnected_players = {}

# Permission bits; these are only relevant to managed users. External users can never do more than playing.
# When changing this, also change the permission bits below (search "permission_list").
PERM_GROUP = 0x01	# User may create and remove groups and change chapter access.
PERM_EDIT = 0x02	# User may edit own group's chapters.
PERM_REVIEW = 0x04	# User may view answers for all players in all groups (this may be made more specific later).
PERM_MANAGE = 0x08	# User may edit player permissions and reset their passwords. This permission is ignored if PERM_REVIEW is not set.
PERM_TEST = 0x10	# All user input is sent to the server and recorded, not just answers. (TODO.)

def refresh_admins(wake): # {{{
	for a in admins:
		yield from admins[a]._refresh(wake)
# }}}

# Class for handling user script commands. {{{
# There can be multiple implementations of te Environment class.
# Only Lua is defined. This is not expected to change.
# It needs to define:
# - constructor with no arguments (or no constructor).
# - set(self, key, value):
#	Set a value in the game's namespace.
# - run(self, wake, script, allow_ui = True):
#	Run code in the game's namespace.
#	If allow_ui is True, animation commands are allowed from the script.
#	This function must be a generator.
# - compute(self, wake, expr, as_str):
#	Run code in the game's namespace and return a value.
#	The value is a str if as_str is True, a bool otherwise.
#	This function must be a generator.
# - module(self, name, value):
#	Load the value dict into the environment as the name name.

class Lua: # Run Lua code. {{{
	'''This class handles the userspace lua environment.
	It uses the lua library, which is safe for running untrusted code.
	'''
	def __init__(self):
		self.lua = lua.Lua()
	def set(self, wake, key, value):
		self.lua.run(var = key, value = value)
		return
		yield
	def run(self, wake, script, allow_ui = True):
		#log('running %s' % script)
		return self.lua.run(script)
		yield
	def compute(self, wake, expr, as_str):
		#log('computing: %s' % expr)
		ret = self.lua.run('return ' + expr)
		if as_str:
			return str(ret)
		else:
			return bool(ret)
		yield
	def module(self, wake, name, value):
		self.lua.module(name, value)
		return
		yield
# }}}

import lua

def Environment():
	return Lua()
# }}}

class Admin_Connection: # {{{ Class for handling admin connections.
	def __init__(self, my_id, my_name, my_userdata, my_remote, managed_name): # {{{
		# Remote connection is never allowed to be an admin.
		assert managed_name is not None

		self.id = my_id
		self.name = my_name
		self.userdata = my_userdata
		self.remote = my_remote
		admins[my_id] = self
		debug(1, 'admin {} connected'.format(self.name))
	def _init(self, wake):
		# Admin connections must have PERM_REVIEW set.
		permissions = (yield from self.userdata.select('id', ('permissions',), wake = wake))
		assert len(permissions) > 0 and permissions[0][0] & PERM_REVIEW
		self.may_manage = permissions[0][0] & PERM_MANAGE

		self.group = None
		self.script = None
		yield from self.select_group(wake)
	# }}}
	def _closed(self): # {{{
		del admins[self.id]
		debug(1, 'disconnected admin {}'.format(self.name))
	# }}}

	# Set new state. {{{
	def select_group(self, wake = None): # {{{
		if wake is None:
			wake = (yield)
		self.group = None
		self.script = None
		self.chapter = None
		self.player = None
		self.question = None
		def refresh(wake):
			groups = (yield from serverdata.select('group', ('name',), wake = wake))
			self.remote.select_group.event([x[0] for x in groups])
		self._refresh = refresh
		yield from self._refresh(wake)
	# }}}
	def select_script(self, group): # {{{
		wake = (yield)
		self.group = (yield from serverdata.select('group', ('id',), ('=', 'name', group), wake = wake))[0][0]
		self.script = None
		self.chapter = None
		self.player = None
		self.question = None
		self._refresh = lambda wake: self.remote.select_script(group, (yield from content.list(wake, self.group)))
		yield from self._refresh(wake)
	# }}}
	def show_script(self, script): # {{{
		wake = (yield)
		self.script = ((yield from content.get_scriptid(wake, script)), '\t'.join(script))
		self.chapter = (yield from content.parse_script_list(wake, script))
		self.player = None
		self.question = None
		if len((yield from serverdata.select('access', ('groupid',), ('and', ('=', 'groupid', self.group), ('=', 'chapter', self.chapter)), wake = wake))) != 1:
			# Ignore this request; refresh with old settings.
			self.script = None
			self.chapter = None
			yield from self._refresh(wake)
			return
		def refresh(wake):
			q = (yield from serverdata.select('question', ('id', 'description', 'type'), ('=', 'script', self.script[0]), wake = wake))
			questions = [{key: iq[idx] for idx, key in enumerate(('id', 'description', 'type'))} for iq in q]
			players = (yield from serverdata.list_managed_players(wake = wake))
			ret = []
			answers = []
			for p in players:
				answers.append((yield from self._get_answers(wake, self.script[1], p['name'])))
			for q in questions:
				ret.append({'tag': q['id'], 'type': q['type'], 'description': q['description'], 'answers': []})
				for ip, p in enumerate(players):
					if q['id'] not in answers[ip]:
						ret[-1]['answers'].append(None)
						continue
					ret[-1]['answers'].append(answers[ip][q['id']][-1])
			self.remote.show_script.event(script, players, ret)
		self._refresh = refresh
		yield from self._refresh(wake)
	# }}}
	def show_player(self, player): # {{{
		wake = (yield)
		if self.chapter is None:
		    return
		self.player = player
		self.question = None
		def refresh(wake):
			questions = (yield from serverdata.select('question', ('id', 'description', 'type'), ('=', 'script', self.script[0]), wake = wake))
			answers = (yield from self._get_answers(wake, self.script[1], self.player))
			self.remote.show_player.event(player, questions, answers)
		self._refresh = refresh
		yield from self._refresh(wake)
	# }}}
	def show_question(self, question): # {{{
		wake = (yield)
		self.player = None
		self.question = question
		def refresh(wake):
			players = (yield from serverdata.list_managed_players(wake = wake))
			ret = []
			for p in players:
				a = (yield from p['userdata'].select('answer', ('answer', 'style'), ('and', ('=', 'script', script), ('=', 'question', self.question)), wake = wake))
				ret.append({'player': p['name'], 'answers': [{'answer': json.loads(x[0]), 'style': x[1]} for x in a]})
			self.remote.show_question.event(question, ret)
		self._refresh = refresh
		yield from self._refresh(wake)
	# }}}
	# }}}

	def _get_answers(self, wake, script, player): # {{{
		ret = {}
		a = (yield from serverdata.managed_select(player, 'answer', ('question', 'answer', 'style'), ('=', 'script', script), wake = wake))
		for question, answer, style in a:
			if question not in ret:
				ret[question] = []
			ret[question].append({'answer': json.loads(answer), 'style': style})
		return ret
	# }}}
# }}}

class Content_Connection: # {{{ Class for handling content management.
	def __init__(self, my_id, my_name, my_userdata, my_remote, managed_name): # {{{
		# Remote connection is never allowed to edit content.
		assert managed_name is not None

		self.id = my_id
		self.name = my_name
		self.userdata = my_userdata
		self.remote = my_remote
		self.managed_name = managed_name
	def _init(self, wake):
		# Connections must have PERM_GROUP or PERM_EDIT set.
		permissions = (yield from self.userdata.select('id', ('permissions',), wake = wake))
		assert len(permissions) > 0
		self.may_edit_group = permissions[0][0] & PERM_GROUP
		self.may_edit_content = permissions[0][0] & PERM_EDIT
		assert self.may_edit_group or self.may_edit_content
		self.chapter = -1	# None is in use for global objects.
	# }}}
	def get_permissions(self): # {{{
		wake = (yield)
		permissions = (yield from self.userdata.select('id', ('permissions',), wake = wake))
		if len(permissions) == 0:
			return {}
		permissions = permissions[0][0]
		ret = {}
		if permissions & PERM_GROUP:
			ret['group'] = True
		if permissions & PERM_EDIT:
			ret['edit'] = True
		return ret
	# }}}
	# Groups {{{
	def list_groups(self):
		wake = (yield)
		assert self.may_edit_group
		data = (yield from serverdata.select('group', ('id', 'name'), wake = wake))
		return {d[0]: {'name': d[1]} for d in data}
	def add_group(self, name):
		wake = (yield)
		assert self.may_edit_group
		return (yield from serverdata.insert('group', {'name': name}, wake = wake))
	def update_group(self, groupid, name):
		wake = (yield)
		assert self.may_edit_group
		yield from serverdata.update('group', {'name': name}, ('=', 'id', groupid), wake = wake)
	def remove_group(self, groupid):
		wake = (yield)
		assert self.may_edit_group
		yield from serverdata.delete('group', ('=', 'id', groupid), wake = wake)
	# }}}
	# Chapters {{{
	def _list_chapters(self, wake):
		data = (yield from serverdata.select('chapter', ('id', 'name'), wake = wake))
		return {d[0]: {'name': d[1]} for d in data}
	def list_chapters(self):
		wake = (yield)
		assert self.may_edit_group
		return (yield from self._list_chapters(wake))
	def _add_chapter(self, wake, name, parent):
		return (yield from serverdata.insert('chapter', {'name': name, 'parent': parent if parent else None}, wake = wake))
	def add_chapter(self, name, parent):
		wake = (yield)
		assert self.may_edit_group
		return (yield from self._add_chapter(wake, name, parent))
	def update_chapter(self, chapterid, name, parent):
		wake = (yield)
		assert self.may_edit_group
		yield from serverdata.update('chapter', {'name': name, 'parent': parent if parent else None}, ('=', 'id', chapterid), wake = wake)
	def remove_chapter(self, chapterid):
		wake = (yield)
		assert self.may_edit_group
		yield from serverdata.delete('chapter', ('=', 'id', chapterid), wake = wake)
	def set_chapter(self, chapterid):
		wake = (yield)
		assert self.may_edit_content
		assert chapterid in (yield from self._list_chapters(wake))
		self.chapter = chapterid
	# }}}
	# Access {{{
	def list_access(self):
		wake = (yield)
		assert self.may_edit_group
		return (yield from serverdata.select('access', ('groupid', 'chapter'), wake = wake))
	def add_access(self, groupid, chapterid):
		wake = (yield)
		assert self.may_edit_group
		present = (yield from serverdata.select('access', ('groupid',), ('and', ('=', 'groupid', groupid), ('=', 'chapter', chapterid)), wake = wake))
		assert len(present) == 0
		yield from serverdata.insert('access', {'groupid': groupid, 'chapter': chapterid}, wake = wake)
	def remove_access(self, groupid, chapterid):
		wake = (yield)
		assert self.may_edit_group
		yield from serverdata.delete('access', ('and', ('=', 'groupid', groupid), ('=', 'chapter', chapterid)), wake = wake)
	# }}}
	# Scripts {{{
	def _list_scripts(self, wake):
		assert self.chapter >= 0
		data = (yield from serverdata.select('script', ('id', 'name', 'chapter'), wake = wake))
		return {d[0]: {'name': d[1], 'chapter': d[2]} for d in data if d[2] in (None, self.chapter)}
	def list_scripts(self):
		wake = (yield)
		assert self.may_edit_content
		return (yield from self._list_scripts(wake))
	def _get_script(self, wake, scriptid):
		assert self.chapter >= 0
		data = (yield from serverdata.select('script', ('script', 'chapter'), ('=', 'id', scriptid), wake = wake))
		return None if len(data) == 0 or data[0][1] not in (None, self.chapter) else data[0][0]
	def get_script(self, scriptid):
		wake = (yield)
		assert self.may_edit_content
		return (yield from self._get_script(wake, scriptid))
	def _add_script(self, wake, name, chapter, script):
		assert self.chapter >= 0
		return (yield from serverdata.insert('script', {'name': name, 'chapter': chapter, 'script': script}, wake = wake))
	def add_script(self, name, script):
		wake = (yield)
		assert self.may_edit_content
		assert self.chapter > 0
		new_scriptid = (yield from self._add_script(wake, name, self.chapter, script))
		return (yield from self._update_questions(wake, new_scriptid, script))
	def update_script(self, scriptid, name, script):
		wake = (yield)
		assert self.may_edit_content
		assert self.chapter >= 0
		data = (yield from serverdata.select('script', ('chapter',), ('=', 'id', scriptid), wake = wake))
		assert len(data) == 1 and data[0][0] == self.chapter
		if script is None:
			yield from serverdata.update('script', {'name': name, 'chapter': self.chapter}, ('=', 'id', scriptid), wake = wake)
			return []
		else:
			yield from serverdata.update('script', {'name': name, 'chapter': self.chapter, 'script': script}, ('=', 'id', scriptid), wake = wake)
			return (yield from self._update_questions(wake, scriptid, script))
	def remove_script(self, scriptid):
		wake = (yield)
		assert self.may_edit_content
		assert self.chapter >= 0
		data = (yield from serverdata.select('script', ('chapter',), ('=', 'id', scriptid), wake = wake))
		assert len(data) == 1 and data[0][0] == self.chapter
		yield from serverdata.delete('script', ('=', 'id', scriptid), wake = wake)
		yield from serverdata.delete('question', ('=', 'script', scriptid), wake = wake)
	# }}}
	# Questions {{{
	def _update_questions(self, wake, scriptid, script):
		assert self.chapter >= 0
		parsed, errors, questions = content.parse_script(script)
		#print('questions', questions)
		yield from serverdata.delete('question', ('=', 'script', scriptid), wake = wake)
		for q in questions:
			yield from serverdata.insert('question', {'id': q['id'], 'script': scriptid, 'type': q['type'], 'description': q['description']}, wake = wake)
		return errors
	def list_questions(self):
		wake = (yield)
		assert self.may_edit_content
		assert self.chapter >= 0
		scripts = (yield from self._list_scripts(wake))
		ret = {}
		print('scripts', scripts)
		for s in scripts:
			data = (yield from serverdata.select('question', ('id', 'type', 'description'), ('=', 'script', s), wake = wake))
			print('questions', repr(data))
			ret.update({('%d:%s' % (s, d[0])): {'type': d[1], 'description': d[2]} for d in data})
		return ret
	# }}}
	# Sprites {{{
	def _list_sprites(self, wake):
		assert self.chapter >= 0
		data = (yield from serverdata.select('sprite', ('tag', 'name', 'chapter', 'id'), ('=', 'chapter', self.chapter), wake = wake))
		return {d[3]: {'tag': d[0], 'name': d[1], 'chapter': d[2]} for d in data}
	def list_sprites(self):
		wake = (yield)
		assert self.may_edit_content
		return (yield from self._list_sprites(wake))
	def _add_sprite(self, wake, tag, name):
		assert self.chapter >= 0
		return (yield from serverdata.insert('sprite', {'tag': tag, 'name': name, 'chapter': self.chapter}, wake = wake))
	def add_sprite(self, tag, name):
		wake = (yield)
		assert self.may_edit_content
		return (yield from self._add_sprite(wake, tag, name))
	def update_sprite(self, spriteid, tag, name):
		wake = (yield)
		assert self.may_edit_content
		assert self.chapter >= 0
		data = (yield from serverdata.select('sprite', ('chapter',), ('=', 'id', spriteid), wake = wake))
		assert len(data) == 1 and data[0][0] == self.chapter
		yield from serverdata.update('sprite', {'tag': tag, 'name': name}, ('=', 'id', spriteid), wake = wake)
	def remove_sprite(self, spriteid):
		wake = (yield)
		assert self.may_edit_content
		assert self.chapter >= 0
		data = (yield from serverdata.select('sprite', ('chapter',), ('=', 'id', spriteid), wake = wake))
		assert len(data) == 1 and data[0][0] == self.chapter
		yield from serverdata.delete('sprite', ('=', 'id', spriteid), wake = wake)
	# }}}
	# Images {{{
	def _list_images(self, wake):
		assert self.chapter >= 0
		sprites = (yield from self._list_sprites(wake))
		data = (yield from serverdata.select('image', ('id', 'sprite', 'mood', 'width', 'height', 'hotx', 'hoty'), wake = wake))
		return {d[0]: {'sprite': d[1], 'mood': d[2], 'size': (d[3], d[4]), 'hotspot': (d[5], d[6])} for d in data if d[1] in sprites}
	def list_images(self):
		wake = (yield)
		assert self.may_edit_content
		return (yield from self._list_images(wake))
	def _get_image(self, wake, imageid):
		assert self.chapter >= 0
		sprites = (yield from self._list_sprites(wake))
		data = (yield from serverdata.select('image', ('url', 'sprite', 'mood', 'width', 'height', 'hotx', 'hoty'), ('=', 'id', imageid), wake = wake))
		if len(data) == 0:
			return None
		assert data[0][1] in sprites
		return None if len(data) == 0 else {'url': data[0][0], 'sprite': data[0][1], 'mood': data[0][2], 'size': [data[0][3], data[0][4]], 'hotspot': [data[0][5], data[0][6]]}
	def get_image(self, imageid):
		wake = (yield)
		assert self.may_edit_content
		return (yield from self._get_image(wake, imageid))
	def _add_image(self, wake, sprite, mood, url, size, hotspot):
		# TODO: load image and detect size.
		assert self.chapter >= 0
		sprites = (yield from self._list_sprites(wake))
		assert sprite in sprites
		return (yield from serverdata.insert('image', {'sprite': sprite, 'mood': mood, 'url': url, 'width': size[0], 'height': size[1], 'hotx': hotspot[0], 'hoty': hotspot[1]}, wake = wake))
	def add_image(self, sprite, mood, url, size, hotspot):
		wake = (yield)
		assert self.may_edit_content
		return (yield from self._add_image(wake, sprite, mood, url, size, hotspot))
	def update_image(self, imageid, sprite, mood, url, size, hotspot):
		wake = (yield)
		assert self.may_edit_content
		assert self.chapter >= 0
		# TODO: load image and detect size.
		sprites = (yield from self._list_sprites(wake))
		assert sprite in sprites
		data = (yield from serverdata.select('image', ('sprite',), ('=', 'id', imageid), wake = wake))
		assert len(data) == 1 and data[0][0] in sprites
		if url is None:
			yield from serverdata.update('image', {'sprite': sprite, 'mood': mood, 'width': size[0], 'height': size[1], 'hotx': hotspot[0], 'hoty': hotspot[1]}, ('=', 'id', imageid), wake = wake)
		else:
			yield from serverdata.update('image', {'sprite': sprite, 'mood': mood, 'url': url, 'width': size[0], 'height': size[1], 'hotx': hotspot[0], 'hoty': hotspot[1]}, ('=', 'id', imageid), wake = wake)
	def remove_image(self, imageid):
		wake = (yield)
		assert self.may_edit_content
		assert self.chapter >= 0
		sprites = (yield from self._list_sprites(wake))
		data = (yield from serverdata.select('image', ('sprite',), ('=', 'id', imageid), wake = wake))
		assert len(data) == 1 and data[0][0] in sprites
		yield from serverdata.delete('image', ('=', 'id', imageid), wake = wake)
	# }}}
	# Audio {{{
	def _list_audio(self, wake):
		assert self.chapter >= 0
		data = (yield from serverdata.select('audio', ('id', 'name', 'chapter', 'duration'), wake = wake))
		return {d[0]: {'name': d[1], 'chapter': d[2], 'duration': d[3]} for d in data if d[2] in (None, self.chapter)}
	def list_audio(self):
		assert self.chapter >= 0
		wake = (yield)
		assert self.may_edit_content
		return (yield from self._list_audio(wake))
	def _get_audio(self, wake, audioid):
		assert self.chapter >= 0
		data = (yield from serverdata.select('audio', ('url', 'chapter'), ('=', 'id', audioid), wake = wake))
		return None if len(data) == 0 or data[0][1] not in (None, self.chapter) else data[0][0]
	def get_audio(self, audioid):
		wake = (yield)
		assert self.may_edit_content
		return (yield from self._get_audio(wake, audioid))
	def _add_audio(self, wake, name, url, duration):
		assert self.chapter >= 0
		# TODO: load sound and detect duration.
		return (yield from serverdata.insert('audio', {'name': name, 'chapter': self.chapter, 'url': url, 'duration': duration}, wake = wake))
	def add_audio(self, name, url, duration):
		wake = (yield)
		assert self.may_edit_content
		return (yield from self._add_audio(wake, name, url, duration))
	def update_audio(self, audioid, name, url, duration):
		wake = (yield)
		assert self.may_edit_content
		assert self.chapter >= 0
		# TODO: load sound and detect duration.
		data = (yield from serverdata.select('audio', ('chapter',), ('and', ('=', 'id', audioid), ('=', 'chapter', self.chapter)), wake = wake))
		assert len(data) == 1
		if url is None:
			yield from serverdata.update('audio', {'name': name, 'duration': duration}, ('=', 'id', audioid), wake = wake)
		else:
			yield from serverdata.update('audio', {'name': name, 'url': url, 'duration': duration}, ('=', 'id', audioid), wake = wake)
	def remove_audio(self, audioid):
		wake = (yield)
		assert self.may_edit_content
		assert self.chapter >= 0
		data = (yield from serverdata.select('audio', ('chapter',), ('and', ('=', 'id', audioid), ('=', 'chapter', self.chapter)), wake = wake))
		assert len(data) == 1
		yield from serverdata.delete('audio', ('=', 'id', audioid), wake = wake)
	# }}}
	def import_chapter(self, zipdata): # {{{
		wake = (yield)
		assert self.may_edit_group and self.may_edit_content
		errors = []
		z = zipfile.ZipFile(io.BytesIO(base64.b64decode(zipdata)), 'r')

		# Read metadata as list of lines. {{{
		metafiles = [x for x in z.infolist() if x.filename.endswith('/info.txt') and len(x.filename.split('/')) == 2]
		if len(metafiles) != 1:
			errors.append('Invalid chapter: must have exactly one metadata info file.')
			return errors
		meta = [x for x in z.read(metafiles[0]).decode('utf-8').split('\n') if x.strip() != '']
		# }}}

		# sprite <name>
		# mood <mood> size <w> <h> hotspot <x> <y>
		# audio <name> duration <duration>

		sprite = {}
		audio = {}
		# Parse metadata into useable structure. {{{
		current = None
		for line in meta:
			if len(line.strip()) == 0:
				continue
			parts = re.match('sprite (\S+)\s*$', line)
			if parts:
				name = parts.group(1)
				if name in sprite:
					errors.append('duplicate sprite in metadata: %s' % name)
					continue
				current = name
				sprite[current] = {}
				continue
			parts = re.match('mood (\S*) size (\S+) (\S+) hotspot (\S+) (\S+)\s*$', line)
			if parts:
				if current is None:
					errors.append('mood defined in metadata before sprite')
					continue
				name = parts.group(1)
				if name in sprite[current]:
					errors.append('duplicate mood %s defined for sprite %s' % (name, current))
					continue
				size = (float(parts.group(2)), float(parts.group(3)))
				hotspot = (float(parts.group(4)), float(parts.group(5)))
				sprite[current][name] = {'size': size, 'hotspot': hotspot}
				continue
			parts = re.match('audio (\S+) duration (\S+)\s*$', line)
			if parts:
				name = parts.group(1)
				if name in audio:
					errors.append('duplicate audio defined: %s' % name)
					continue
				audio[name] = float(parts.group(2))
				continue
			errors.append('imported content contains invalid metadata: %s' % line)
			continue
		# }}}

		chaptername = metafiles[0].filename.split('/')[0]
		chapterid = (yield from (self._add_chapter(wake, chaptername, None)))

		# Create all new sprites.
		for spritename in sprite:
			# Store the id in None, because string keys are mood names.
			sprite[spritename][None] = (yield from self._add_sprite(wake, spritename, chapterid))

		for info in z.infolist():
			parts = info.filename.split('/')
			if parts[0] != chaptername:
				errors.append('ignoring path with incorrect top level directory: %s != %s' % (parts[0], chaptername))
				continue
			target = parts[-1].rsplit('.', 1)
			if len(target) == 1:
				errors.append('ignoring path without extension: %s' % info.filename)
				continue
			if target[1] != 'txt':
				errors.append('ignoring non-txt extension: %s' % info.filename)
				continue
			target = target[0]

			# Do not attempt to parse the metadata here, it has been parsed above.
			if target == 'info':
				continue

			# Sprite mood image.
			if parts[1] == 'sprite':
				if len(parts) != 4:
					errors.append('ignoring path in imported zipfile: %s' % parts[1])
					continue
				if parts[2] not in sprite:
					errors.append('ignoring sprite without metadata: %s' % parts[2])
					continue
				if target not in sprite[parts[2]]:
					errors.append('ignoring sprite: mood is not defined in metadata: %s,%s' % (parts[2], target))
					continue
				s = sprite[parts[2]][target]
				yield from self._add_image(wake, sprite[parts[2]][None], target, z.read(info).decode('utf-8'), s['size'], s['hotspot'])
				continue

			# All other files need to have 3 path parts.
			if len(parts) != 3:
				errors.append('ignoring path in imported zipfile, because it does not have 3 parts: %s' % info.filename)
				continue

			# Script.
			if parts[1] == 'script':
				yield from self._add_script(wake, target, chapterid, z.read(info).decode('utf-8', 'replace'))

			# Audio.
			elif parts[1] == 'audio':
				if target not in audio:
					errors.append('ignoring audio without metadata: %s' % target)
					continue
				yield from self._add_audio(wake, target, chapterid, z.read(info).decode('utf-8'), audio[target])

			# Video (not implemented yet)
			elif parts[1] == 'video':
				errors.append('ignoring video path in imported zipfile (not implemented yet)')

			# Unsupported path.
			else:
				errors.append('ignoring unsupported path in imported zipfile: %s' % parts[1])
		return errors
	# }}}
	def export_chapter(self, chapterid): # {{{
		wake = (yield)
		assert self.may_edit_content
		chaptername = (yield from serverdata.select('chapter', ('name',), ('=', 'id', chapterid), wake = wake))[0][0]
		ret = io.BytesIO()
		z = zipfile.ZipFile(ret, 'w')
		images = {}
		info = b''
		for scriptid, data in (yield from self._list_scripts(wake)).items():
			script = (yield from self._get_script(wake, scriptid)).encode('utf-8')
			with z.open('%s/script/%s.txt' % (chaptername, data['name']), 'w') as f:
				f.write(script)
		for imageid, im in (yield from self._list_images(wake)).items():
			if im['sprite'] not in images:
				images[im['sprite']] = {}
			images[im['sprite']][im['mood']] = {'id': imageid, 'size': im['size'], 'hotspot': im['hotspot']}
		for spriteid, sprite in (yield from self._list_sprites(wake)).items():
			if sprite['chapter'] != chapterid:
				continue
			info += b'sprite %s\n' % sprite['name'].encode('utf-8')
			for mood in images[spriteid]:
				imageid = images[spriteid][mood]['id']
				url = (yield from self._get_image(wake, imageid))['url'].encode('utf-8')
				with z.open('%s/sprite/%s/%s.txt' % (chaptername, sprite['name'], mood), 'w') as f:
					f.write(url)
				info += b'mood %s size %f %f hotspot %f %f\n' % (mood.encode('utf-8'), images[spriteid][mood]['size'][0], images[spriteid][mood]['size'][1], images[spriteid][mood]['hotspot'][0], images[spriteid][mood]['hotspot'][1])
		for audioid, metadata in (yield from self._list_audio(wake)).items():
			data = (yield from self._get_audio(wake, audioid)).encode('utf-8')
			if data is None:
				print('ignoring invalid audio id %s' % audioid, file = sys.stderr)
				continue
			info += b'audio %s duration %f\n' % (metadata['name'].encode('utf-8'), metadata['duration'])
			with z.open('%s/audio/%s.txt' % (chaptername, metadata['name']), 'w') as f:
				f.write(data)
		with z.open('%s/info.txt' % chaptername, 'w') as f:
			f.write(info)
		z.close()
		return 'data:application/zip;base64,' + base64.b64encode(ret.getbuffer()).decode('utf-8')
	# }}}
# }}}

class Connection: # {{{
	# Internals. {{{
	def __init__(self, my_id, my_name, my_userdata, my_remote, managed_name): # {{{
		self.id = my_id
		self.name = my_name
		self.userdata = my_userdata
		self.remote = my_remote
		self.managed_name = managed_name
		self.display_name = my_name + (' (%s)' % managed_name if managed_name is not None else '')
	# }}}
	def _closed(self): # {{{
		wake = (yield)
		if self.managed_name is not None:
			users[self.id]['connection'] = None
			assert self.managed_name not in disconnected_players
			disconnected_players[self.managed_name] = users[self.id]
		del users[self.id]
		yield from refresh_admins(wake)
	# }}}
	def _init(self, wake): # {{{
		self.busy = False
		debug(2, 'New connection from {}:{}'.format(*self.remote.socket.remote))
		if self.managed_name in disconnected_players:
			u = disconnected_players.pop(self.managed_name)
		else:
			u = {
				'program': [],
				'run_stack': [],
				'chapter': None,	# Current chapter.
				'question': None,	# Question that is currently being asked.
				'option': [],		# Current list of options, for use by next question.
				'kinetic': [],		# Pending kinetic commands. This is a stack, similar to run_stack.
				'args': [],		# Stack of default arguments.
			}
		users[self.id] = u
		u['name'] = self.name
		u['connection'] = self
		self.user = u
		# Find user's group. {{{
		data = (yield from self.userdata.select('id', ('my_group',), wake = wake))
		print('found group', data)
		if len(data) == 0:
			groupname = (yield from serverdata.select('group', ('name',), ('=', 'id', 1), wake = wake))
			if len(groupname) == 0:
				groupname = [['']]
			yield from self.userdata.insert('id', {'my_group': groupname[0][0], 'permissions': 0}, wake = wake)
			print('added group', groupname[0][0])
			my_group = 1
		else:
			g = (yield from serverdata.select('group', ('id',), ('=', 'name', data[0][0]), wake = wake))
			print('lookup group', g)
			if len(g) != 1:
				my_group = 1
			else:
				my_group = g[0][0]
		print('use group', my_group)
		u['group'] = my_group
		# }}}
		debug(1, 'User {}:{} logged in from {}:{}'.format(self.name, my_group, *self.remote.socket.remote))
		scripts = (yield from content.list(wake, my_group))
		# Strip common chapters from script names. {{{
		u['chapterprefix'] = []
		if len(scripts) > 0:
			while len(scripts[0]) > 1 and all(x[0] == scripts[0][0] for x in scripts):
				u['chapterprefix'].append(scripts[0][0])
				for s in scripts:
					s.pop(0)
		# }}}
		self.remote.contents.event(scripts)
		self.remote.main.event(self.display_name)
		if u['chapter'] is not None:
			if len(u['run_stack']) > 0 and len(u['run_stack'][-1]['program']) > 1:
				setup = []
				state = u['_kinetic_state']
				if state['background'] is not None:
					setup.append({'action': 'scene', 'image': state['background'][0], 'mood': state['background'][1], 'args': {'with': None}})
				else:
					setup.append({'action': 'scene', 'image': None, 'mood': None, 'args': {'with': None}})
				if state['font']:
					setup.append({'action': 'font', 'css': state['font']})
				for spr in state['sprite']:
					s = state['sprite'][spr]
					arg = {'action': 'move', 'image': self.user['sprite'][spr]['id'], 'mood': s['mood']}
					arg.args = {x: s[x] for x in ('from', 'from_hotspot', 'to', 'to_hotspot', 'scale', 'scale_hotspot', 'rotation', 'rotation_hotspot')}
					arg.args.update({'with': None, 'around': None, 'in': None})
					setup.append(arg)
				self.remote.kinetic.event(setup, state['music'])
				if not (yield from self._run_item(wake, u['run_stack'][-1]['program'][u['run_stack'][-1]['current']])):
					debug(0, 'Bug: saved state of user {}:{} was not a waiting state'.format(name, group))
					yield from self._run(wake)
		yield from refresh_admins(wake)
	# }}}
	def _safe_eval(self, wake, expr, as_str): # {{{
		'Evaluate an expression through Lua.'
		try:
			ret = (yield from self.user['environment'].compute(wake, expr, as_str))
			return str(ret) if as_str else ret
		except ValueError as e:
			print('error:', str(e))
			print('in eval:', expr)
			traceback.print_exc()
			return str(e) if as_str else False
	# }}}
	def _parse_text(self, wake, text): # {{{
		'Do substitutions on a text that is going to be shown to the user. This should be called with "yield from".'
		if text is None:
			return None
		result = ''
		for m in re.finditer('\${(.*?)}|[^$]+', text):
			if m.group(1) is None:
				# This is not a substitution; add the string to the result.
				result += m.group(0)
			else:
				# This is a substitution; add the evaluated string to the result.
				result += (yield from self._safe_eval(wake, m.group(1), as_str = True))
		return result
	# }}}
	def _parse_time(self, wake, t): # {{{
		'Parse a string (possibly including substitutions) as a time. Units of s for seconds or ms for milliseconds are required. This should be called with "yield from".'
		i = (yield from self._parse_text(wake, t)).strip()
		r = re.match(r'([-+.e0-9]+)\s*(m?)s$', i)
		if r is None:
			return None
		else:
			try:
				num = float(r.group(1))
				if r.group(2) == 'm':
					num /= 1e3
				return num
			except ValueError:
				debug(0, 'error parsing time {}'.format(i))
				return None
	# }}}
	def _answer(self, wake, style): # {{{
		'''Set style for last answer. This should be called with "yield from".'''
		if wake is None:
			wake = (yield)
		if self.user['answered'] is None:
			debug(1, 'answer style given before a question was answered')
			return
		style = (yield from self._parse_text(wake, style))
		yield from self.userdata.update('answer', {'style': style}, ('and', ('=', 'question', self.user['answered']), ('=', 'script', self.user['scripttag'])), wake = wake)
		yield from refresh_admins(wake)
	# }}}
	def _sprite(self, tag, id, name, mood = ''): # {{{
		self.user['sprite'][tag] = {'name': name, 'id': id, 'mood': mood}
	# }}}
	def _home(self, wake): # {{{
		self.user['chapter'] = None
		del self.user['environment']
		yield from refresh_admins(wake)
		self.remote.main.event(self.display_name)
	# }}}
	def _parse_animation_args(self, wake, item_args, defaults): # {{{
		def parse_location(wake, loc): # {{{
			'Parse location; return location and hotspot'
			if loc is None:
				return None, [0, 0]
			raw = (yield from self._parse_text(wake, loc))
			if '@' in raw:
				h, pos = loc.split('@')
				hotspot = [float(x) for x in h.split(',')]
			else:
				pos = loc
				hotspot = [None, None]
			l = [x.strip() for x in pos.split(',')]
			h = [None, None]
			if l[0] == 'outleft':
				l[0] = -1
				h[0] = 1
			elif l[0] == 'inleft':
				l[0] = -1
				h[0] = -1
			elif l[0] == 'outright':
				l[0] = 1
				h[0] = -1
			elif l[0] == 'inright':
				l[0] = 1
				h[0] = 1
			elif l[0] == 'left':
				l[0] = -.4
				h[0] = 0
			elif l[0] == 'center':
				l[0] = 0
				h[0] = 0
			elif l[0] == 'right':
				l[0] = .4
				h[0] = 0
			else:
				try:
					l[0] = float(l[0])
				except:
					l[0] = 0
			if hotspot[0] is not None:
				h[0] = hotspot[0]
			if len(l) == 1:
				l.append(None)
			elif l[1] == 'outbottom':
				l[1] = 0
				h[1] = 1
			elif l[1] == 'inbottom':
				l[1] = 0
				h[1] = -1
			elif l[1] == 'outtop':
				l[1] = 1
				h[1] = -1
			elif l[1] == 'intop':
				l[1] = 1
				h[1] = 1
			elif l[1] == 'bottom':
				l[1] = 0
				h[1] = 0
			elif l[1] == 'low':
				l[1] = .2
				h[1] = 0
			elif l[1] == 'middle':
				l[1] = .5
				h[1] = 0
			elif l[1] == 'high':
				l[1] = .8
				h[1] = 0
			elif l[1] == 'top':
				l[1] = 1
				h[1] = 0
			else:
				try:
					l[1] = float(l[1])
				except:
					l[1] = None
			if hotspot[1] is not None:
				h[1] = hotspot[1]
			if len(l) == 2:
				l.append(None)
			else:
				try:
					l[2] = int(l[2])
				except:
					l[2] = None
			if h == [None, None]:
				h = None
			return l, h
		# }}}
		def parse_around(wake, loc): # {{{
			if loc is None:
				return None
			l = [x.strip() for x in (yield from self._parse_text(wake, loc)).split(',')]
			if l[-1] in ('cw', 'ccw'):
				cw = l[-1] == 'cw'
				l.pop()
			else:
				cw = False
			if l[0] == 'left':
				l[0] = -.4
			elif l[0] == 'center':
				l[0] = 0
			elif l[0] == 'right':
				l[0] = .4
			else:
				try:
					l[0] = float(l[0])
				except:
					l[0] = 0
			if len(l) == 1:
				l.append(0)
			elif l[1] == 'bottom':
				l[1] = 0
			elif l[1] == 'low':
				l[1] = .2
			elif l[1] == 'middle':
				l[1] = .5
			elif l[1] == 'high':
				l[1] = .8
			elif l[1] == 'top':
				l[1] = 1
			else:
				try:
					l[1] = float(l[1])
				except:
					l[1] = 0
			return l[:2] + [cw]
		# }}}
		args = {}
		if item_args['in'] is None: # {{{
			args['in'] = None
		else:
			args['in'] = (yield from self._parse_time(wake, item_args['in']))
		# }}}
		args['to'], args['to_hotspot'] = (yield from parse_location(wake, item_args['to']))
		if args['in'] is None and defaults.get('in') is None:
			args['with'] = 'jump'
			args['from'], args['from_hotspot'] = args['to'], args['to_hotspot']
		else:
			args['from'], args['from_hotspot'] = (yield from parse_location(wake, item_args['from']))
		if args['from'] is not None:
			if args['from'][0] is None:
				args['from'][0] = 0
			if args['from'][1] is None:
				args['from'][1] = 0
		if item_args['with'] is None: # {{{
			args['with'] = 'move'
		else:
			w = (yield from self._parse_text(wake, item_args['with']))
			if w not in ('jump', 'fade', 'move'):
				debug(0, 'invalid transition {}'.format(w))
				args['with'] = None
			else:
				args['with'] = w
		# }}}
		args['around'] = (yield from parse_around(wake, item_args['around']))
		if item_args['scale'] is None: # {{{
			args['scale'] = None
			args['scale_hotspot'] = None
		else:
			raw = (yield from self._parse_text(wake, item_args['scale']))
			if '@' in raw:
				value, hotspot = raw.split('@')
				s = [x.strip() for x in value.split(',')]
				h = [x.strip() for x in hotspot.split(',')]
			else:
				s = [x.strip() for x in raw.split(',')]
				h = None
			try:
				def parse(num):
					if num.endswith('%'):
						return float(num[:-1]) / 100
					return float(num)
				s = [parse(x) for x in s]
				if len(s) == 1:
					s.append(s[0])
				elif len(s) > 2:
					s = [s[0], s[1]]
			except:
				debug(0, 'error parsing scale {}'.format(s))
				s = None
			args['scale'] = s
			args['scale_hotspot'] = h
		# }}}
		if item_args['rotation'] is None: # {{{
			args['rotation'] = None
			args['rotation_hotspot'] = None
		else:
			raw = (yield from self._parse_text(wake, item_args['rotation'])).strip()
			if '@' in raw:
				r, hotspot = raw.split('@')
				h = [x.strip() for x in hotspot.split(',')]
			else:
				r = raw
				h = None
			if r.endswith('°'):
				f = 360
				r = r[:-1]
			else:
				f = 1
			try:
				r = float(r) / f
			except:
				debug(0, 'error parsing rotation {}'.format(r))
				r = None
			args['rotation'] = r
			args['rotation_hotspot'] = h
		# }}}
		ret = defaults.copy()
		ret.update({k: v for k, v in args.items() if k not in ret or v is not None})
		return ret
	# }}}
	def _continue_break(self, cmd): # {{{
		while self.user['run_stack'][-1]['current'] >= len(self.user['run_stack'][-1]['program']) or self.user['run_stack'][-1]['program'][self.user['run_stack'][-1]['current']]['command'] != 'while':
			if self.user['run_stack'][-1]['kinetic']:
				self.user['kinetic'].pop()
				self.user['args'].pop()
			self.user['run_stack'].pop()
		if cmd == 'break':
			self.user['run_stack'][-1]['current'] += 1
	# }}}
	def _clear_pending(self): # {{{
		# update kinetic state.
		def handle_action(action, state):
			if action['action'] in ('speech', 'sound', 'wait'):
				# Nothing to update.
				pass
			elif action['action'] == 'scene':
				state['background'] = (action['image'], action['mood'])
			elif action['action'] == 'music':
				state['music'] = action['target']
			elif action['action'] == 'font':
				state['font'] = action['css']
			elif action['action'] in ('serial', 'parallel'):
				for a in action['actions']:
					handle_action(a, state)
			elif action['action'] == 'hide':
				if action['image'] is not None:
					del state['sprite'][action['image']]
			else:
				assert action['action'] == 'move'

				# If target sprite does not exist, create it (with no image).
				if action['image'] not in state['sprite']:
					state['sprite'][action['image']] = {'from': [0, 0, None], 'from_hotspot': None, 'to': [0, 0, None], 'to_hotspot': None, 'scale': None, 'scale_hotspot': None, 'rotation': None, 'rotation_hotspot': None, 'image': None}
				# Store target sprite in local variable.
				target = state['sprite'][action['image']]

				# Set mood image.
				target['image'] = action['image']
				target['mood'] = action['mood']
				args = action['args']
				for prop in ('from', 'from_hotspot', 'to', 'to_hotspot', 'scale', 'scale_hotspot', 'rotation', 'rotation_hotspot'):
					if args.get(prop) is not None:
						target[prop] = args[prop]
		if len(self.user['kinetic']) != 1:
			log('Error: Pending cleared while kinetic stack is not a single level:', self.user['kinetic'])
		else:
			for action in self.user['kinetic'][0]:
				handle_action(action, self.user['_kinetic_state'])
		#debug(0, repr(self.user['kinetic'][0]))
		self.user['kinetic'] = [[]]
		self.user['args'] = [{}]
	# }}}
	def _start(self, wake, script_content, send_errors): # {{{
		self.user['program'], errors, question = script_content
		if send_errors:
			if len(errors) > 0:
				errors = markdown('# Errors:\n' + '\n\n'.join(errors))
			else:
				errors = ''
			self.remote.error.event(errors)
		self.user['run_stack'] = [{'program': self.user['program'], 'current': 0, 'kinetic': False}]	# Set kinetic to False so it isn't popped at end of script.
		self.user['kinetic'] = [[]]
		self.user['args'] = [{}]
		# Sprites are stored in two steps.
		# All available sprites are loaded into user['moods'] by this function.
		# All active sprites (declared with a "sprite" command, may or may not be onscreen) are in user['sprite']. Both are dicts.
		# user['moods'] has sprite names (as defined in db) as keys. Its values are dicts with mood names as keys and their numerical image ids as values.
		# user['sprite'] has tags as used in the script as keys. Its values are dicts with items:
		#   'name': The character's name that is shown on screen as the speaker name,
		#   'id': The db sprite name, which is used as the key in user['moods'] and
		#   'mood': The currently active mood, for when there is speech without an explicit mood.
		self.user['moods'] = {}
		self.user['sprite'] = {}
		self.user['question'] = None
		self.user['answered'] = None
		self.user['option'] = []
		# Set up self.user['moods']. {{{
		global_sprites = (yield from serverdata.select('sprite', ('id', 'tag', 'name'), ('=', 'chapter', None), wake = wake))
		local_sprites = (yield from serverdata.select('sprite', ('id', 'tag', 'name'), ('=', 'chapter', self.user['chapter']), wake = wake))
		spriteid = {tag: (id, name) for id, tag, name in global_sprites}
		spriteid.update({tag: (id, name) for id, tag, name in local_sprites})
		for tag in spriteid:
			id, name = spriteid[tag]
			moods = (yield from serverdata.select('image', ('mood', 'id'), ('=', 'sprite', id), wake = wake))

			# Record available moods.
			self.user['moods'][tag] = {m[0]: m[1] for m in moods}

			# Initialize sprite with image tag as code tag.
			self._sprite(tag, tag, name)

		moods = {tag: list(self.user['moods'][tag].keys()) for tag in spriteid}
		# }}}
		# Set up self.user['audio']. {{{
		global_audio = (yield from serverdata.select('audio', ('id', 'name'), ('=', 'chapter', None), wake = wake))
		local_audio = (yield from serverdata.select('audio', ('id', 'name'), ('=', 'chapter', self.user['chapter']), wake = wake))
		audioid = {name: id for id, name in global_audio}
		audioid.update({name: id for id, name in local_audio})
		self.user['audio'] = audioid
		# }}}
		self.user['environment'] = Environment()
		module = {
			'name': self.user['name'],
			'group': self.user['group'],
			'chapter': self.user['chapter'],
			'script': self.user['script'],
			# Available sprites and moods. Example: {'person': ['', 'happy', 'sad'], 'bg': ['', 'inside', 'outside']}
			'moods': moods,
			# Active sprites. This object can be manipulated to change the appearance of the sprite (speaker name and image collection; mood is (also) changed through kinetic commands).
			'sprite': self.user['sprite'],
			# Available audio.
			'audio': list(self.user['audio'].keys()),

			# These are handled immediately.
			# Record answer style
			'answer': lambda style: (yield from self._answer(None, style)),
			# Activate a sprite. call as make_sprite(tag, name, id, mood). Using lambda to make sure it's not a member.
			'make_sprite': lambda tag, id, name, mood = '': self._sprite(tag, id, name, mood),
			# Add kinetic commands to the pending queue.
			'kinetic': lambda actions: self.user['kinetic'][-1].extend(actions),

			# These are used for building kinetic commands.
			'speech': lambda speaker, target, mood, side, text: {'action': 'speech', 'speaker': speaker, 'target': target, 'mood': mood, 'side': side, 'text': markdown(text)},
			'wait': lambda seconds: {'action': 'wait', 'time': seconds},
			'sound': lambda tag: {'action': 'sound', 'tag': tag},
			'music': lambda tag: {'action': 'music', 'tag': tag},
			'serial': lambda *parts: {'action': 'serial', 'parts': parts},
			'parallel': lambda *parts: {'action': 'parallel', 'parts': parts},
			'move': lambda target, image, mood, args: {'action': 'move', 'target': target, 'image': image, 'mood': mood, 'args': (yield from self._parse_animation_args(wake, args, self.user['args'][-1]))},
			'hide': lambda target, image, mood, args: {'action': 'hide', 'target': target, 'image': image, 'mood': mood, 'args': (yield from self._parse_animation_args(wake, args, self.user['args'][-1]))},

			# These can be returned.
			'video': lambda tag: {'cmd': 'video', 'video': tag},
			'question': lambda type, tag, text, options = None: {'cmd': 'question', 'tag': tag, 'type': type, 'text': text, 'option': options},
			'continue': lambda: {'cmd': 'continue'},
			'break': lambda: {'cmd': 'break'},
		}
		yield from self.user['environment'].module(wake, 'vn', module)

		startup = fhs.read_data(os.path.join('include', 'startup.lua'))
		if startup is not None:
			try:
				yield from self.user['environment'].run(wake, startup.read(), False)
			except:
				debug(1, 'Error in startup script')
				traceback.print_exc()
		yield from self._run(wake)
	# }}}
	def _question(self, wake, qtype, tag, text, options): # {{{
		# Handle hidden type differently (don't inform player).
		if qtype == 'hidden':
			parsed = yield from self._safe_eval(wake, text, as_str = True)
			yield from self._store_answer(wake, tag, {'raw': parsed, 'text': parsed, 'style': []})
			return False

		# Modify type to make it easier for brower code.
		if qtype == 'unit':
			qtype = 'short'
		if qtype == 'longunit':
			qtype = 'longshort'
		qtext = markdown((yield from self._parse_text(wake, text)))

		# Parse options.
		parsed_options = []
		if options is not None:
			for x in options:
				parsed_options.append((yield from self._parse_text(wake, x)))

		# Send question to player.
		if len(self.user['kinetic']) != 1:
			log('Error: question sent while kinetic stack is not a single level: {}'.format(self.user['kinetic']))
		self.remote.question.event(self.user['kinetic'][0], qtext, qtype, parsed_options)

		# Prepare for answer.
		self.user['question'] = {'type': qtype, 'tag': tag}

		return True
	# }}}
	def _find_mood(self, target, mood): # {{{
		if target not in self.user['sprite']:
			return None, None
		image = self.user['sprite'][target]
		if image['id'] not in self.user['moods'] or (mood is not None and mood not in self.user['moods'][image['id']]):
			return None, None
		if mood is None:
			if image['mood'] in self.user['moods'][image['id']]:
				mood = image['mood']
			elif '' in self.user['moods'][image['id']]:
				mood = ''
			else:
				mood = None
		return image['id'], mood
	# }}}
	def _run(self, wake): # {{{
		watchdog = 0
		while len(self.user['run_stack']) > 0:
			watchdog += 1
			if watchdog > 1000:
				debug(1, 'hanging script detected: {}; killing it'.format(self.user['chapter']))
				self.remote.error.event(['Script stopped working and was killed.'])
				self.user['run_stack'] = [{'program': self.user['program'], 'current': len(self.user['program']), 'kinetic': False}]
				self.user['kinetic'] = [[]]
				yield from refresh_admins(wake)
				return
			# Pop off stack levels until there's an instruction.
			while len(self.user['run_stack'][-1]['program']) <= self.user['run_stack'][-1]['current']:
				kinetic = self.user['kinetic'][-1]
				if self.user['run_stack'][-1]['kinetic']:
					self.user['kinetic'].pop()
					self.user['args'].pop()
				self.user['run_stack'].pop()
				#print('pop', self.user['run_stack'])
				if len(self.user['run_stack']) == 0:
					# Send final "question".
					if len(self.user['kinetic']) != 1:
						log('Error: script ends while kinetic stack is not empty')
					self.remote.question.event(kinetic, '', 'choice', ['Done'])
					yield from refresh_admins(wake)
					return
			# Run instructions.
			if (yield from self._run_item(wake, self.user['run_stack'][-1]['program'][self.user['run_stack'][-1]['current']])):
				#print('break')
				break
			#print('no break')
		yield from refresh_admins(wake)
	# }}}
	def _run_item(self, wake, code): # {{{
		'''Run one command. Return True if execution should be stopped.'''
		debug(3, '{}:{} running item {} args {}'.format(self.user['name'], self.user['group'], repr(code), repr(self.user['args'])))
		if code['command'] == 'answer': # {{{
			yield from self._answer(wake, code['answer'])
		# }}}
		elif code['command'] == 'if': # {{{
			self.user['run_stack'][-1]['current'] += 1
			for expr, target in code['code']:
				if expr is None or (yield from self._safe_eval(wake, expr, as_str = False)):
					self.user['run_stack'].append({'program': target, 'current': 0, 'kinetic': False})
					break
			return False
		# }}}
		elif code['command'] == 'while': # {{{
			# Don't increment instruction pointer, so the loop restarts.
			if (yield from self._safe_eval(wake, code['test'], as_str = False)):
				self.user['run_stack'].append({'program': code['code'], 'current': 0, 'kinetic': False})
			else:
				# exit the while loop.
				self.user['run_stack'][-1]['current'] += 1
				# handle else clause, if present.
				if code['else'] is not None:
					self.user['run_stack'].append({'program': code['else'], 'current': 0, 'kinetic': False})
			return False
		# }}}
		elif code['command'] in ('continue', 'break'): # {{{
			self._continue_break(code['command'])
			return False
		# }}}
		elif code['command'] == 'code': # {{{
			try:
				cmd = (yield from self.user['environment'].run(wake, code['code']))
			except:
				debug(0, 'Error in script: {}'.format(code['code']))
				traceback.print_exc()
				self.remote.error.event(code['code'])
				cmd = None
			if isinstance(cmd, dict) and 'cmd' in cmd:
				if cmd['cmd'] == 'video':
					if len(self.user['kinetic']) != 1:
						log('Error: video requested (from Lua) while kinetic stack is not a single level')
					self.remote.video.event(self.user['kinetic'][0], cmd['video'])
					return True
				elif cmd['cmd'] == 'question':
					if any(x not in cmd for x in ('type', 'tag', 'text', 'option')):
						log('Error: invalid question returned from Lua code')
						return False
					if (yield from self._question(wake, cmd['type'], cmd['tag'], cmd['text'], cmd['option'])):
						return True
					# Fall through: increment command pointer.
				elif cmd['cmd'] in ('continue', 'break'):
					self._continue_break(cmd['cmd'])
					return False
			self.user['run_stack'][-1]['current'] += 1
			return False
		# }}}
		elif code['command'] == 'video': # {{{
			if len(self.user['kinetic']) != 1:
				log('Error: video requested while kinetic stack is not a single level')
			self.remote.video.event(self.user['kinetic'][0], code['video'])
			return True
		# }}}
		elif code['command'] == 'speech': # {{{
			target = code['speaker']
			#print('check', item, self.user['sprite'])
			speaker = None if target is None else self.user['sprite'][target]['name'] if target in self.user['sprite'] else '(' + target + ')'

			# Set images.
			image, mood = self._find_mood(target, code['mood'])
			if target in self.user['sprite'] and 'side' in self.user['sprite'][target]:
				side = self.user['sprite'][target]['side']
			else:
				side = None
			self.user['kinetic'][-1].append({'action': 'speech', 'speaker': speaker, 'target': target, 'image': image, 'mood': mood, 'side': side, 'text': markdown((yield from self._parse_text(wake, code['markdown'])))})
		# }}}
		elif code['command'] == 'wait': # {{{
			self.user['kinetic'][-1].append({'action': 'wait', 'time': (yield from self._parse_time(wake, code['time']))})
		# }}}
		elif code['command'] in ('sound', 'music'): # {{{
			target = None if code['target'] is None else (yield from self._parse_text(wake, code['target']))
			self.user['kinetic'][-1].append({'action': code['command'], 'target': target})
		# }}}
		elif code['command'] == 'scene': # {{{
			args = (yield from self._parse_animation_args(wake, code['args'], self.user['args'][-1]))
			image = (yield from self._parse_text(wake, code['image']))
			mood = (yield from self._parse_text(wake, code['mood']))
			if image in self.user['moods'] and (mood is None or mood in self.user['moods'][image]):
				if mood is None and '' in self.user['moods'][image]:
					mood = ''
			else:
				image = None
				mood = None
			self.user['kinetic'][-1].append({'action': 'scene', 'image': image, 'mood': mood, 'args': args})
		# }}}
		elif code['command'] in ('move', 'hide'): # {{{
			args = (yield from self._parse_animation_args(wake, code['args'], self.user['args'][-1]))
			if code['target'] is None:
				target = None
				mood = None
				image = None
			else:
				target = (yield from self._parse_text(wake, code['target']))
				mood = (yield from self._parse_text(wake, code['mood']))
				image, mood = self._find_mood(target, mood)
			self.user['kinetic'][-1].append({'action': code['command'], 'target': target, 'image': image, 'mood': mood, 'args': args})
		# }}}
		elif code['command'] in ('serial', 'parallel'): # {{{
			new_list = []
			self.user['kinetic'][-1].append({'action': code['command'], 'actions': new_list})
			self.user['kinetic'].append(new_list)
			new_args = (yield from self._parse_animation_args(wake, code['args'], self.user['args'][-1]))
			self.user['args'].append(new_args)
			self.user['run_stack'][-1]['current'] += 1
			self.user['run_stack'].append({'program': code['actions'], 'current': 0, 'kinetic': True})
			return False
		# }}}
		elif code['command'] == 'option': # {{{
			self.user['option'].append((yield from self._parse_text(wake, code['option'])))
		# }}}
		elif code['command'] == 'question': # {{{
			self.user['question'] = code
			if (yield from self._question(wake, code['type'], code['tag'], code['text'], self.user['option'])):
				# Don't increment current command; that happens in answer.
				return True
		# }}}
		else:
			debug(0, 'invalid command {}'.format(code))
		self.user['run_stack'][-1]['current'] += 1
		return False
	# }}}
	def _update_sprite(self, tag, data): # {{{
		for item in ('x', 'y', 'mood'):
			if item in data:
				self.user['characters'][tag][item] = data[item]
		c = self.user['characters'][tag]
		data['url'] = c['imgs'] + (data.pop('mood') if 'mood' in data else 'default') + c['ext']
	# }}}
	def _store_answer(self, wake, question, answer, store = True): # {{{
		yield from (self.user['environment'].set(wake, question, answer))
		if store:
			yield from self.userdata.insert('answer', {'script': self.user['scripttag'], 'question': question, 'answer': json.dumps(answer)}, wake = wake)
			self.user['answered'] = question
		else:
			self.user['answered'] = None
	# }}}
	# }}}
	def get_sprite_image(self, sprite_name, sprite_mood): # {{{
		'Retrieve image from database. Return data url.'
		wake = (yield)
		if sprite_name in self.user['moods']:
			if sprite_mood in self.user['moods'][sprite_name]:
				imageid = self.user['moods'][sprite_name][sprite_mood]
			elif '' in self.user['moods'][sprite_name]:
				imageid = self.user['moods'][sprite_name]['']
			else:
				imageid = None
		else:
			if '' in self.user['moods']:
				s = self.user['moods']['']
				if sprite_mood in s:
					imageid = s[sprite_mood]
				elif '' in s:
					imageid = s['']
				else:
					imageid = None
			else:
				imageid = None
		data = (yield from serverdata.select('image', ('url', 'width', 'height', 'hotx', 'hoty'), ('=', 'id', imageid), wake = wake))
		if len(data) != 1:
			print('Warning: sprite %s mood %s not found and no fallback found either' % (sprite_tag, sprite_mood), file = sys.stderr)
			return {'url': None, 'size': (0, 0), 'hotspot': (0, 0)}
		#print('image id', imageid, 'from', repr(self.user['moods']), 'data', data[0][0][:30])
		return {'url': data[0][0], 'size': (data[0][1], data[0][2]), 'hotspot': (data[0][3], data[0][4])}
	# }}}
	def get_audio(self, audioid): # {{{
		'Retrieve audio from database. Return data url.'
		wake = (yield)
		if audioid not in self.user['audio']:
			log('invalid audio tag %s requested' % audioid)
		data = (yield from serverdata.select('audio', ('url', 'duration'), ('=', 'id', self.user['audio'][audioid]), wake = wake))
		if len(data) != 1:
			log('failed to get audio %s (id %d)' % (audioid, self.user['audio'][audioid]))
			return None
		return {'url': data[0][0], 'duration': data[0][1]}
	# }}}
	def home(self): # {{{
		wake = (yield)
		if self.busy and not force:
			traceback.print_stack()
			log('attempt to home while busy')
			return
		yield from self._home(wake)
	# }}}
	def start(self, script): # {{{
		wake = (yield)
		if self.busy:
			log('attempt to start while busy')
			traceback.print_stack()
			return
		self.user['_kinetic_state'] = {'background': None, 'sprite': {}, 'music': None}
		self.busy = True
		chapterid, scriptid, code = (yield from content.get(wake, self.user['group'], self.user['chapterprefix'] + script))
		self.user['scripttag'] = '\t'.join(self.user['chapterprefix'] + script)
		self.user['chapter'] = chapterid
		self.user['script'] = scriptid
		try:
			yield from self._start(wake, code, False)
		finally:
			self.busy = False
	# }}}
	def answer(self, answer): # {{{
		wake = (yield)
		if self.busy:
			log('attempt to answer while busy')
			return
		debug(2, '{}:{} answers {}'.format(self.user['name'], self.user['group'], answer))
		if len(self.user['run_stack']) == 0:
			# Ignore answer for final "Done" button.
			debug(2, 'ignoring final Done button')
			yield from self._home(wake)
			return
		self._clear_pending()
		if self.user['run_stack'][-1]['current'] >= len(self.user['run_stack'][-1]['program']):
			debug(1, 'end of stack frame?!')
			self.busy = True
			try:
				yield from self._run(wake)
			finally:
				self.busy = False
			return
		current = self.user['question']
		if current is None or current['type'] not in ('short', 'long', 'choice', 'unit', 'longshort', 'longunit', 'longchoice'):
			debug(1, 'answer given by {}:{} for non-question: {}'.format(self.remote.socket.remote[0], self.remote.socket.remote[1], current))
			return
		store = not current['tag'].startswith('_')
		def parse_unit(src): # {{{
			r = re.match(r'\s*(?:(\S+)\s*=\s*)?([+-]?[0-9]*(?:[.,]\d*)?)(?:·10([⁻⁺]?[⁰¹²³⁴⁵⁶⁷⁸⁹]+))?\s*(\S*)\s*$', src)
			# groups:
			# 1: quantity	(\S+)
			# 2: base value	([+-]?[0-9]*(?:[.,]\d*)?)
			# 3: exponent	(·10([⁻⁺]?[⁰¹²³⁴⁵⁶⁷⁸⁹]+))?
			# 4: unit	(\S*)
			if not r or r.group(1) is None:
				debug(3, 'no match for unit answer')
				answer = {'quantity': None, 'unit': None, 'digits': None, 'value': None}
			else:
				try:
					answer = {}
					answer['quantity'] = r.group(1)
					base = r.group(2).replace(',', '.')
					exponent = None if r.group(3) is None else int(fromsuper(r.group(3)))
					answer['unit'] = r.group(4)
					answer['digits'] = len(base.replace('.', '').lstrip('0'))
					answer['value'] = float(base) * (1 if exponent is None else 10 ** exponent)
				except:
					traceback.print_exc()
					answer = {'quantity': None, 'unit': None, 'digits': None, 'value': None}
			debug(3, 'unit-split answer: {}'.format(answer))
			return answer
		# }}}
		raw = answer
		debug(1, 'raw: %s store %d' % (repr(raw), store))
		if current['type'] == 'choice':
			if isinstance(answer, int) and 1 <= answer <= len(self.user['option']):
				answer = {'index': answer, 'text': self.user['option'][answer - 1]}
			else:
				answer = {}
			if len(self.user['option']) <= 1:
				store = False
		elif current['type'] == 'longchoice':
			if isinstance(answer[0], int) and 1 <= answer[0] <= len(self.user['option']):
				answer = {'index': answer[0], 'text': self.user['option'][answer[0] - 1], 'long': str(answer[1]).strip()}
			else:
				# Leave answer string as is (but force str); this only happens when users are messing with the js.
				debug(2, 'unparsable longchoice answer: {}'.format(answer))
				answer = {'choice': None, 'long': str(answer).strip()}
		elif current['type'] == 'unit':
			answer = parse_unit(answer)
		elif current['type'] == 'longunit':
			l = answer[1]
			try:
				answer = parse_unit(answer[0])
				answer['long'] = l
			except:
				# Leave answer string as is (but force str); this only happens when users are messing with the js.
				debug(2, 'unparsable longunit answer: {}'.format(answer))
				answer = {}
		elif current['type'].startswith('long') and current['type'] != 'long':
			try:
				answer = {'text': str(answer[0]).strip(), 'long': str(answer[1]).strip()}
			except:
				# Leave answer string as is (but force str); this only happens when users are messing with the js.
				debug(2, 'unparsable long* answer: {}'.format(answer))
				answer = {}
		else:
			answer = {'text': answer}
		answer['raw'] = raw
		answer['style'] = []
		debug(1, 'answer: %s store %d' % (repr(answer), store))
		yield from self._store_answer(wake, current['tag'], answer, store)
		self.user['run_stack'][-1]['current'] += 1
		self.user['option'] = []
		self.busy = True
		try:
			yield from self._run(wake)
		finally:
			self.busy = False
	# }}}
	def video_done(self): # {{{
		wake = (yield)
		if self.busy:
			log('attempt to finish video while busy')
			return
		self._clear_pending()
		if self.user['run_stack'][-1]['current'] >= len(self.user['run_stack'][-1]['program']):
			self.busy = True
			try:
				yield from self._run(wake)
			finally:
				self.busy = False
			return
		current = self.user['run_stack'][-1]['program'][self.user['run_stack'][-1]['current']]
		if current[0] == 'video':
			self.user['run_stack'][-1]['current'] += 1
			self.busy = True
			try:
				yield from self._run(wake)
			finally:
				self.busy = False
	# }}}
# }}}

def connection_selector(my_id, my_name, my_userdata, my_remote, managed_name): # {{{
	parts = my_remote.data['url'].strip('/').split('/')
	# example parts: ['content', 'index.html', 'websocket']
	if len(parts) > 2:
		if parts[-3] == 'admin':
			return Admin_Connection(my_id, my_name, my_userdata, my_remote, managed_name)
		if parts[-3] == 'content':
			return Content_Connection(my_id, my_name, my_userdata, my_remote, managed_name)
	return Connection(my_id, my_name, my_userdata, my_remote, managed_name)
# }}}

db_config = { # {{{
	# Permissions # {{{
	'group': [
		('id', 'int(11) NOT NULL AUTO_INCREMENT PRIMARY KEY'),
		('name', 'text NOT NULL')
	],
	'chapter': [
		('id', 'int(11) NOT NULL AUTO_INCREMENT PRIMARY KEY'),
		('name', 'text NOT NULL'),
		('parent', 'int(11) DEFAULT NULL'),
	],
	'access': [
		('groupid', 'int(11) NOT NULL'),
		('chapter', 'int(11) DEFAULT NULL'),
	],
	# }}}

	# Scripts {{{
	'script': [
		('id', 'int(11) NOT NULL AUTO_INCREMENT PRIMARY KEY'),
		('name', 'text NOT NULL'),
		('chapter', 'int(11) NOT NULL'),
		('script', 'longtext NOT NULL')
	],
	'question': [
		('id', 'text NOT NULL'),
		('script', 'int(11) NOT NULL'),
		('type', 'varchar(255) NOT NULL'),
		('description', 'varchar(255) NOT NULL')
	],
	# }}}

	# Images {{{
	'sprite': [
		('id', 'int(11) NOT NULL AUTO_INCREMENT PRIMARY KEY'),	# Sprite id.
		('tag', 'text NOT NULL'),	# Sprite tag name.
		('name', 'text NOT NULL'),	# Sprite display name.
		('chapter', 'int(11) DEFAULT NULL'),	# Chapter id, or NULL for global sprites.
	],
	'image': [
		('id', 'int(11) NOT NULL AUTO_INCREMENT PRIMARY KEY'),
		('sprite', 'int(11) NOT NULL'),	# Sprite id.
		('mood', 'text NOT NULL'),	# Mood name.
		('url', 'longtext NOT NULL'),	# Data url.

		# Size of image in screen units.
		('width', 'float NOT NULL'),
		('height', 'float NOT NULL'),

		# Location of hotspot in screen units.
		# The origin for the hotspot coordinates is the bottom left corner of the image.
		('hotx', 'float NOT NULL'),
		('hoty', 'float NOT NULL'),
	],
	# }}}

	# Media {{{
	'audio': [
		('id', 'int(11) NOT NULL AUTO_INCREMENT PRIMARY KEY'),
		('chapter', 'int(11) DEFAULT NULL'),
		('name', 'varchar(255) NOT NULL'),
		('url', 'longtext NOT NULL'),	# Data url.
		('duration', 'int(11) NOT NULL'),
	],
	# }}}
} # }}}
player_config = { # {{{
	'id': [	# This table has only one row.
		('my_group', 'varchar(255) NOT NULL'),
		('permissions', 'int(5) NOT NULL'),	# Change this when changing permission_list (written as one word for easier searching).
	],
	'answer': [
		('script', 'mediumtext NOT NULL'),	# tab-separated list of chapters.
		('question', 'text NOT NULL'),
		('answer', 'mediumtext NOT NULL'),
		('style', 'mediumtext DEFAULT NULL'),
	]
} # }}}

# Main program {{{
server, serverdata = userdata.setup(connection_selector, config, db_config, player_config, httpdirs = ('html',), proxy = config['proxy'])
content.init(serverdata)

print('server is running on port {}'.format(config['port']), file = sys.stderr)
websocketd.fgloop()
# }}}

# vim: set foldmethod=marker :
